---
tags: 
alias:
---

https://cloud.tencent.com/developer/beta/article/1784046
保活就是在用户主动杀进程，或者系统基于当前内存不足状态而触发清理进程后，该进程设法让自己免于被杀的命运或者被杀后能立刻重生的手段。

#### 主流思路有两个：

-   提升进程[[Android 进程优先级]]，降低被杀概率
- App间关联唤醒，打开一个App的时候会启动、唤醒其他App。

最好的方案那肯定是跟各大系统厂商建立合作关系，把App加入系统内存清理的白名单；比如微信，降低oom_adj值，尽量保证进程不被系统杀死。

## Android 8.0之前-常用的保活方案

1.开启一个前台Service  
2.Android 6.0+ 忽略电池优化开关(`稍后会有代码`)  
3.无障碍服务(只针对有用这个功能的app，如支付宝语音增强提醒用了它)

## Android 8.0之后-常用的保活方案
### 开启一个前台Service
### 忽略电池优化(Android 6.0+)
需要用户授权。
### 无障碍服务
[**创建自己的无障碍服务**](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.com%2Fguide%2Ftopics%2Fui%2Faccessibility%2Fservice%3Fhl%3Dzh-cn "https://developer.android.com/guide/topics/ui/accessibility/service?hl=zh-cn")  
它也是一个Service，它的优先级比较高，提供界面增强功能，初衷是帮助视觉障碍的用户或者是可能暂时无法与设备进行全面互动的用户完成操作。  
可以做很多事情，使用了此Service，在6.0+不需要申请悬浮窗权限，直接使用`WindowManager.LayoutParams.TYPE_ACCESSIBILITY_OVERLAY` 挺方便的  
(`仅针对`有需要此服务的app，可以开启`增强后台保活`)
### 自启动权限(即：白名单管理列表页面)
是系统给用户自己去打开“自启动权限”开关的入口，我们需要针对不同的手机厂商和系统版本，弹出提示`引导用户`是否前去打开“自启动权限”  
有的手机厂商叫：`白名单管理`，有的叫：`自启动权限`，两个是一个概念；

### 多任务列表窗口加锁

可以针对不同手机厂商，显示引导用户，`开启App窗口加锁`之后，点击清理加速`不会导致应用被kill`

### 多任务列表窗口隐藏App窗口
刚刚上面多任务窗口加锁完，再提示用户去App里面把`隐藏App窗口`开关打开，这样用户就`不会`在`多任务列表`里面把App窗口给`手抖划掉`

多任务窗口中『`隐藏App窗口`』，可以用如下代码控制：  
(这个也只是`针对有这方面需求App`提供的一种`增强方案`罢了：`因为隐藏了窗口，用户就不会去想他，不会去手痒去划掉它`)

### 应用后台高耗电(`Vivo手机独有`)


-   startForeground 启动前台服务（官方提供，会有通知，保活性不高
    
    -   进阶点：开启前台Service，再开启另一个Service将通知栏移除
-   多任务列表窗口加锁
    
-   多任务列表窗口隐藏App
    
-   多个app关联唤醒
    
-   忽略电池优化开关

-   应用自启动权限(各个系统不一样)
    
-   QQ 的 1 像素（**可以使进程的优先级在屏幕锁屏时间由4提升为最高优先级1**
    
-   后台无声音乐


## 白色保活
-   用startForeground()启动前台服务，这是官方提供的后台保活方式，不足的就是通知栏会常驻一条通知，像360的状态栏。

## 灰色保活
-   开启前台Service，开启另一个Service将通知栏移除，其oom_adj值还是没变的，这样用户就察觉不到app在后台保活。

-   用广播唤醒自启，像开机广播、网络切换广播等，但在国产Rom中几乎都被堵上了。

-   多个app关联唤醒，就像BAT的全家桶，打开一个App的时候会启动、唤醒其他App，包括一些第三方推送也是，对于大多数单独app，比较难以实现。
## 黑色保活
像素activity保活方案监听息屏事件，在息屏时启动个一像素的activity，提升自身优先级；

Service中循环播放一段无声音频，伪装音乐app，播放音乐中的app优先级还是蛮高的，也能很大程度保活效果较好，但耗电量高，谨慎使用；

双进程守护，这在国产rom中几乎没用，因为划掉app会把所有相关进程都杀死。

3、实现过程：

1)、用startForeground()启动前台服务

前台Service，使用startForeground这个Service尽量要轻，不要占用过多的系统资源，否则系统在资源紧张时，照样会将其杀死。

-   DaemonService.java



## 实现方案
### 用startForeground()启动前台服务

前台Service，使用startForeground这个Service尽量要轻，不要占用过多的系统资源，否则系统在资源紧张时，照样会将其杀死。

这种保活方式，会在通知栏常驻一条通知。

### 开启前台Service

同时启动两个service，共享同一个NotificationID，并且将他们同时置为前台状态，此时会出现两个前台服务，但通知管理器里只有一个关联的通知。这时我们在其中一个服务中调用 stopForeground(true)，这个服务前台状态会被取消，同时状态栏通知也被移除。另外一个服务并没有受到影响，还是前台服务状态，但是此时，状态栏通知已经没了！

### 像素activity保活方案
屏幕关闭的时候打开一个1px的透明的activity，屏幕开启的时候再去finsh掉这个activty即可
### Service中循环播放一段无声音频
新建一个播放音乐的Service类，将播放模式改为无限循环播放。在其onDestroy方法中对自己重新启动。
