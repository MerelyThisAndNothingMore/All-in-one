---
tags: 
alias:
---


## 滑动冲突场景以及产生原因
产生滑动冲突的场景主要有两种:

-   父ViewGroup和子View的滑动方向一致
-   父ViewGroup和子View的滑动方向不一致

那为什么会产生滑动冲突呢，例如在父ViewGroup和子View的滑动方向一致的情况，我需要让两者都可以滑动。
在上篇博客中我们分析了事件分发机制，其中提到ViewGroup的**onInterceptTouchEvent**方法默认情况下是返回false，也就是ViewGroup默认情况下是不会拦截事件的。
当ViewGroup接收到事件时，由于不拦截事件，会去寻找能够处理事件的子View。
此时，一旦子View处理了DOWN事件，默认情况下接下来同一事件序列的其他事件都交由子View处理，此时可以看到的效果是子View可以滑动，但是父ViewGroup始终滑动不了，此时滑动冲突就出现了。
## 滑动冲突的解决方式

### 外部拦截法
#### 原理
所谓外部拦截法，就是当事件传递到父容器时，通过父容器去判断自己是否需要此事件，若需要则拦截事件，不需要则不拦截事件，将事件传递给子View。
#### 解决方式
这边ViewPager处理事件的条件可以有多种方法，例如水平方向和竖直方向上的滑动速度、水平方向和竖直方向的滑动距离等。这边根据滑动距离判断，当水平方向的滑动距离大于竖直方向的滑动距离，则ViewPager处理事件，反之则将事件传递给ListView。
#### 总结
-   外部拦截法主要是父容器去控制事件的拦截，若事件是父容器需要的，则进行拦截，不需要的则向下传递。
-   父容器不能拦截DOWN事件或者UP事件。
```java
public boolean onInterceptTouchEvent(MotionEvent ev) {
        boolean isIntercept = false;
        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                //DOWN事件不能拦截，否则事件将无法分发到子View
                isIntercept = false;
                break;
            case MotionEvent.ACTION_MOVE:
                //根据条件判断是否拦截事件
                isIntercept = needThisEvent();
                break;
            case MotionEvent.ACTION_UP:
                //一旦父容器拦截了UP事件，子View将无法触发点击事件
                isIntercept = false;
                break;
            default:
                break;
        }
        return isIntercept;
    }
```

### 内部拦截法
#### 冲突场景

下面讲一种稍微复杂一点的同向滑动冲突。ScrollView内部的内部的LinearLayout存在三个子View，从上到下分别为ImageView、ListView以及TextView。

现在需要的效果是
触摸ListView外部的区域，ScrollView的滑动不受限制。

当触摸ListView区域时，存在多种情况。
- 当ListView滚动到顶部时(ListView处于初始状态)，此时若手指往下滑动，则ScrollView往下滑动；
- 当ListView滚动到底部时，若此时手指往上滑动，则ScrollView往上滑动，
- 其余情况下ListView滚动。
#### 原理
内部拦截法： ViewGroup默认情况下不拦截事件，由子View去控制事件的处理，若子View需要此事件，则自己处理，否则交由父容器处理。

使用内部拦截需要同时重写父ViewGroup的onInterceptTouchEvent和ViewGroup中需要解决冲突的子View的dispatchTouchEvent方法，和上面一样，先上伪代码。


#### 总结
-   内部拦截法是将事件控制权交给子View，若子View需要事件，则对事件进行处理，不需要则将事件传递给父ViewGroup，让父ViewGroup处理。
-   子View通过调用父ViewGroup的requestDisallowInterceptTouchEvent来干预父ViewGroup对事件的拦截状况
```java
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            //禁止父容器拦截事件
            getParent().requestDisallowInterceptTouchEvent(true);
            break;
            ...
        }
        ...
    }
}
```
```java
@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_MOVE:
            if (当期View不需要此事件) {
                // 允许父容器拦截事件
                getParent().requestDisallowInterceptTouchEvent(false);
            }
            break;
        default:
            break;
    }
    return super.dispatchTouchEvent(ev);
    }
```
-   父ViewGroup不能拦截DOWN事件，至于MOVE或者UP事件的拦截状态要根据具体的情景

  







