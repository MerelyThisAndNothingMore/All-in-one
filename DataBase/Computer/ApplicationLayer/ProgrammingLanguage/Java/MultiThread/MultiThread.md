---
tags: 
alias:
---
# 线程同步
对于多线程的程序来说，同步指的是在一定的时间内只允许某一个线程访问某个资源，具体可以使用以下四种方式实现：
## 互斥锁（mutex）
_**互斥锁**_ 是最常见的线程同步方式，它是一种特殊的变量，它有 _**lock**_ 和 _**unlock**_ 两种状态，一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取。

## 条件变量（condition）
针对互斥锁浪费资源且效率低的缺点，可以使用条件变量。

条件变量的方法是，当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁，实现高效

条件变量允许线程阻塞并等待另一个线程发送信号，一般和互斥锁一起使用。

条件变量被用来阻塞一个线程，当条件不满足时，线程会解开互斥锁，并等待条件发生变化。一旦其他线程改变了条件变量，将通知相应的阻塞线程，这些线程重新锁定互斥锁，然后执行后续代码，最后再解开互斥锁。
## 读写锁（reader-writer lock）
**读写锁** 也称之为 **共享-独占锁**，一般用在读和写的次数有很大不同的场合。即对某些资源的访问会出现两种情况，一种是访问的排他性，需要独占，称之为写操作；还有就是访问可以共享，称之为读操作。

**读写所** 相比于不管三七二十一，通通独占的模式，有着很大的适用性和并行性。其有以下几种状态：

1.  读写锁处于写锁定的状态，则在解锁之前，所有试图加锁的线程都会阻塞；
2.  读写锁处于读锁定的状态，则所有试图以读模式加锁的线程都可得到访问权，但是以写模式加锁的线程则会阻塞；
3.  读写锁处于读模式的锁（未加锁）状态时，有另外的线程试图以写模式加锁，则读写锁会阻塞读模式加锁的请求，这样避免了读模式锁长期占用，导致的写模式锁长期阻塞的情况；

**适用场景：**

读写锁最适用于对数据结构的毒操作次数多于写操作次数的场合。
## 信号量（semphore）






