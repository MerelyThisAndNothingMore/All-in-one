---
tags: 
alias:
---
# 创建流程
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1kY2FjYTJhYTc4NDMwMGZjLnBuZw?x-oss-process=image/format,png)
## 步骤1：类加载检查
1.  检查 该`new`指令的参数 是否能在 常量池中 定位到一个类的符号引用
2.  检查 该类符号引用 代表的类是否已被加载、解析和初始化过

> 如果没有，需要先执行相应的类加载过程

## 步骤2：为对象分配内存
虚拟机将为对象分配内存，即把一块确定大小的内存从 Java 堆中划分出来
对象所需内存的大小在类加载完成后便可完全确定

关于分配内存，此处主要讲解内存分配方式
内存分配 根据 Java堆内存是否绝对规整 分为两种方式：指针碰撞 & 空闲列表
1. Java堆内存 规整：已使用的内存在一边，未使用内存在另一边
2. Java堆内存 不规整：已使用的内存和未使用内存相互交错
### 方式1：指针碰撞
-   设Java堆内存绝对规整，内存分配将采用指针碰撞
-   分配形式：已使用内存在一边，未使用内存在另一边，中间放一个作为分界点的指示器
-   那么，分配对象内存 = 把指针向 未使用内存 移动一段 与对象大小相等的距离
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS00NTRmMDExYTg2OGU2NmQ1LnBuZw?x-oss-process=image/format,png)
### 方式2：空闲列表
假设Java堆内存不规整，内存分配将采用 空闲列表
分配形式：虚拟机维护着一个 记录可用内存块 的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
额外知识
分配方式的选择 取决于 Java堆内存是否规整；
而 Java堆是否规整 由所采用的垃圾收集器是否带有压缩整理功能决定。因此：
使用带 Compact 过程的垃圾收集器时，采用指针碰撞；
如Serial、ParNew垃圾收集器

使用基于 Mark_sweep算法的垃圾收集器时，采用空闲列表。
如 CMS垃圾收集器
特别注意
对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起线程不安全
如，正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存

所以，给对象分配内存会存在线程不安全的问题。

解决 线程不安全 有两种方案：

同步处理分配内存空间的行为
虚拟机采用 CAS + 失败重试的方式 保证更新操作的原子性

把内存分配行为 按照线程 划分在不同的内存空间进行
即每个线程在 Java堆中预先分配一小块内存（本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB）），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要同步锁。
虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。
## 步骤3： 将内存空间初始化为零值

内存分配完成后，虚拟机需要将分配到的内存空间初始化为零（不包括对象头）

> 1.  保证了对象的实例字段在使用时可不赋初始值就直接使用（对应值 = 0）
> 2.  如使用本地线程分配缓冲（TLAB），这一工作过程也可以提前至TLAB分配时进行。

## 步骤4： 对对象进行必要的设置

如，设置 这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

**这些信息存放在对象的对象头中**。
-   至此，从 `Java` 虚拟机的角度来看，一个新的 `Java`对象创建完毕
-   但从 `Java` 程序开发来说，对象创建才刚开始，需要进行一些初始化操作。


# 对象的内存布局
-   问题：在 `Java` 对象创建后，到底是如何被存储在Java内存里的呢？
-   答：在`Java`虚拟机（`HotSpot`）中，对象在 `Java` 内存中的 存储布局 可分为三块：
    1.  对象头 存储区域
    2.  实例数据 存储区域
    3.  对齐填充 存储区域
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1mOWQyNTk3NTczMjE2NGJjLnBuZw?x-oss-process=image/format,png)
# 对象的访问定位
问：建立对象后，该如何访问对象呢？
实际上需访问的是 对象类型数据 & 对象实例数据

答：Java程序 通过 栈上的引用类型数据（reference） 来访问Java堆上的对象
由于引用类型数据（reference）在 Java虚拟机中只规定了一个指向对象的引用，但没定义该引用应该通过何种方式去定位、访问堆中的对象的具体位置

所以对象访问方式取决于虚拟机实现。目前主流的对象访问方式有两种：

句柄 访问
直接指针 访问
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0yZjQ5MjgxNzNlNzM0ZTNlLnBuZw?x-oss-process=image/format,png)

# Java对象如何判断存活
## 引用计数法
### 方式描述
给 Java 对象添加一个引用计数器
每当有一个地方引用它时，计数器 +1；引用失效则 -1；
### 判断对象存活准则
当计数器不为 0 时，判断该对象存活；否则判断为死亡（计数器 = 0）。

### 优点
实现简单
判断高效
### 缺点
无法解决 对象间相互循环引用 的问题
即该算法存在判断逻辑的漏洞
## 引用链法（可达性分析法）
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0xYTkxYTgzMWM0ZmNmYjgwLnBuZw?x-oss-process=image/format,png)

-   很多主流商用语言（如`Java`、`C#`）都采用 **引用链法** 判断 `Java`对象是否存活。
-   含3个步骤：
    1.  可达性分析
    2.  第一次标记 & 筛选
    3.  第二次标记 & 筛选
### 可达性分析
将一系列的 `GC Roots` 对象作为起点，从这些起点开始向下搜索。

>    可作为 `GC Root` 的对象有：  
>     1.`Java`虚拟机栈（栈帧的本地变量表）中引用的对象  
>     2.本地方法栈 中 `JNI`引用对象  
>     3.方法区 中常量、类静态属性引用的对象
>   向下搜索的路径 = 引用链

可达性分析 仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡
当在 可达性分析 中判断不可达的对象，只是“被判刑” = 还没真正死亡
不可达对象会被放在”即将回收“的集合里。

要判断一个对象真正死亡，还需要经历两个阶段：
第一次标记 & 筛选
第二次标记 & 筛选

### 第一次标记 & 筛选
对象 在 可达性分析中 被判断为不可达后，会被第一次标记 & 准备被筛选
a. 不筛选：继续留在 ”即将回收“的集合里，等待回收；
b. 筛选：从 ”即将回收“的集合取出

筛选的标准：该对象是否有必要执行 finalize()方法
若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；
若没必要执行，判断该对象死亡，不筛选 并等待回收
当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执行”
### 第二次标记 & 筛选
当对象经过了第一次的标记 & 筛选，会被进行第二次标记 & 准备被进行 筛选

a. 方式描述
该对象会被放到一个 F-Queue 队列中，并由 虚拟机自动建立、优先级低的Finalizer 线程去执行队列中该对象的finalize()
finalize()只会被执行一次
但并不承诺等待finalize()运行结束。这是为了防止 finalize()执行缓慢 / 停止 使得 F-Queue队列其他对象永久等待。
b. 筛选标准
在执行finalize()过程中，若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象），那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并 等待回收





