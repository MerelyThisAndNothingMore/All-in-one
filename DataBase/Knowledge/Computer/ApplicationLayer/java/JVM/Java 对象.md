---
tags: 
alias:
---
# 创建流程
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0yZGIxYjExYTRjYjk4ZjFiLnBuZw?x-oss-process=image/format,png)
## 步骤1：类加载检查
1.  检查 该`new`指令的参数 是否能在 常量池中 定位到一个类的符号引用
2.  检查 该类符号引用 代表的类是否已被加载、解析和初始化过

> 如果没有，需要先执行相应的类加载过程

## 步骤2：为对象分配内存
虚拟机将为对象分配内存，即把一块确定大小的内存从 Java 堆中划分出来
对象所需内存的大小在类加载完成后便可完全确定

关于分配内存，此处主要讲解内存分配方式
内存分配 根据 Java堆内存是否绝对规整 分为两种方式：指针碰撞 & 空闲列表
1. Java堆内存 规整：已使用的内存在一边，未使用内存在另一边
2. Java堆内存 不规整：已使用的内存和未使用内存相互交错
### 方式1：指针碰撞
-   设Java堆内存绝对规整，内存分配将采用指针碰撞
-   分配形式：已使用内存在一边，未使用内存在另一边，中间放一个作为分界点的指示器
-   那么，分配对象内存 = 把指针向 未使用内存 移动一段 与对象大小相等的距离
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS00NTRmMDExYTg2OGU2NmQ1LnBuZw?x-oss-process=image/format,png)
### 方式2：空闲列表
假设Java堆内存不规整，内存分配将采用 空闲列表
分配形式：虚拟机维护着一个 记录可用内存块 的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录
额外知识
分配方式的选择 取决于 Java堆内存是否规整；
而 Java堆是否规整 由所采用的垃圾收集器是否带有压缩整理功能决定。因此：
使用带 Compact 过程的垃圾收集器时，采用指针碰撞；
如Serial、ParNew垃圾收集器

使用基于 Mark_sweep算法的垃圾收集器时，采用空闲列表。
如 CMS垃圾收集器
特别注意
对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起线程不安全
如，正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存

所以，给对象分配内存会存在线程不安全的问题。

解决 线程不安全 有两种方案：

同步处理分配内存空间的行为
虚拟机采用 CAS + 失败重试的方式 保证更新操作的原子性

把内存分配行为 按照线程 划分在不同的内存空间进行
即每个线程在 Java堆中预先分配一小块内存（本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB）），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要同步锁。
虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。
## 步骤3： 将内存空间初始化为零值











# Java对象如何判断存活
## 引用计数法
### 方式描述
给 Java 对象添加一个引用计数器
每当有一个地方引用它时，计数器 +1；引用失效则 -1；
### 判断对象存活准则
当计数器不为 0 时，判断该对象存活；否则判断为死亡（计数器 = 0）。

### 优点
实现简单
判断高效
### 缺点
无法解决 对象间相互循环引用 的问题
即该算法存在判断逻辑的漏洞
## 引用链法（可达性分析法）
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0xYTkxYTgzMWM0ZmNmYjgwLnBuZw?x-oss-process=image/format,png)

-   很多主流商用语言（如`Java`、`C#`）都采用 **引用链法** 判断 `Java`对象是否存活。
-   含3个步骤：
    1.  可达性分析
    2.  第一次标记 & 筛选
    3.  第二次标记 & 筛选
### 可达性分析
将一系列的 `GC Roots` 对象作为起点，从这些起点开始向下搜索。

>    可作为 `GC Root` 的对象有：  
>     1.`Java`虚拟机栈（栈帧的本地变量表）中引用的对象  
>     2.本地方法栈 中 `JNI`引用对象  
>     3.方法区 中常量、类静态属性引用的对象
>   向下搜索的路径 = 引用链

可达性分析 仅仅只是判断对象是否可达，但还不足以判断对象是否存活 / 死亡
当在 可达性分析 中判断不可达的对象，只是“被判刑” = 还没真正死亡
不可达对象会被放在”即将回收“的集合里。

要判断一个对象真正死亡，还需要经历两个阶段：
第一次标记 & 筛选
第二次标记 & 筛选

### 第一次标记 & 筛选
对象 在 可达性分析中 被判断为不可达后，会被第一次标记 & 准备被筛选
a. 不筛选：继续留在 ”即将回收“的集合里，等待回收；
b. 筛选：从 ”即将回收“的集合取出

筛选的标准：该对象是否有必要执行 finalize()方法
若有必要执行（人为设置），则筛选出来，进入下一阶段（第二次标记 & 筛选）；
若没必要执行，判断该对象死亡，不筛选 并等待回收
当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执行”
### 第二次标记 & 筛选
当对象经过了第一次的标记 & 筛选，会被进行第二次标记 & 准备被进行 筛选

a. 方式描述
该对象会被放到一个 F-Queue 队列中，并由 虚拟机自动建立、优先级低的Finalizer 线程去执行队列中该对象的finalize()
finalize()只会被执行一次
但并不承诺等待finalize()运行结束。这是为了防止 finalize()执行缓慢 / 停止 使得 F-Queue队列其他对象永久等待。
b. 筛选标准
在执行finalize()过程中，若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象），那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并 等待回收





