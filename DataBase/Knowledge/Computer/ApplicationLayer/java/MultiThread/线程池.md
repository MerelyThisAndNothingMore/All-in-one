---
tags: 
alias:
- Thread Pool
---
# 介绍
## 引入
![](https://img-blog.csdnimg.cn/img_convert/c5953e632e3869cc6457a7edc3c0abcd.png)
## 参数
![](https://img-blog.csdnimg.cn/20190423104753143.png)
### corePoolSize 线程池核心线程大小

线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。

### maximumPoolSize 线程池最大线程数量

当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。

### keepAliveTime 空闲线程存活时间

一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定
### unit 空闲线程存活时间单位

keepAliveTime的计量单位

### workQueue 工作队列

新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列

①ArrayBlockingQueue

基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。

②LinkedBlockingQuene

基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。

③SynchronousQuene

一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。

④PriorityBlockingQueue

具有优先级的无界阻塞队列，优先级通过参数Comparator实现。

### threadFactory 线程工厂

创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等

### handler 拒绝策略

当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：

①CallerRunsPolicy

该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。

②AbortPolicy

该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。

③DiscardPolicy

该策略下，直接丢弃任务，什么都不做。

④DiscardOldestPolicy

该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列

## 常见的4类功能线程池
![](https://img-blog.csdnimg.cn/img_convert/8c39dcc0786d030dce0453cb5967e5bb.png)
### 定长线程池（FixedThreadPool）

-   特点：只有核心线程 & 不会被回收、线程数量固定、任务队列无大小限制（超出的线程任务会在队列中等待）
-   应用场景：控制线程最大并发数
-   具体使用：通过 _Executors.newFixedThreadPool()_ 创建

### 定时线程池（ScheduledThreadPool ）

-   特点：核心线程数量固定、非核心线程数量无限制（闲置时马上回收）
-   应用场景：执行定时 / 周期性 任务
-   使用：通过*Executors.newScheduledThreadPool()*创建

### 可缓存线程池（CachedThreadPool）
特点：只有非核心线程、线程数量不固定（可无限大）、灵活回收空闲线程（具备超时机制，全部回收时几乎不占系统资源）、新建线程（无线程可用时）
任何线程任务到来都会立刻执行，不需要等待
应用场景：执行大量、耗时少的线程任务

### 单线程化线程池（SingleThreadExecutor）
特点：只有一个核心线程（保证所有任务按照指定顺序在一个线程中执行，不需要处理线程同步的问题）

应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作，文件操作等

使用：通过*Executors.newSingleThreadExecutor()*创建*
# 使用场景
## IO密集型

## CPU密集型
如果是 CPU 密集型的，可以把核心线程数设置为核心数+1。

# 异常处理
#### Runable执行异常(业务异常)处理方式

由于Runable执行异常并不会影响到整个系统的运行，不会因为在线程池中执行任务报错导致真系统错误退出。所以线程池执行任务的异常处理方式通常有两种：

-   **直接不处理(也可以打印日志)**
-   **捕获异常不让异常往外抛**

#### 提交任务到任务队列已满异常处理

这个异常取决于使用的何种拒绝策略。Java内置的拒绝策略有四种：

-   **CallerRunsPolicy：在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务**
-   **AbortPolicy：直接抛出异常**
-   **DiscardPolicy：会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。**
-   **DiscardOldestPolicy：当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。**
-   **自定义策略，只要实现RejectedExecutionHandler接口**

对于提交任务到任务队列已满异常，如果不进行catch不影响整个整个系统的运行可以不进行处理，如果可能会导致系统中断。就需要对错误进行处理。

#### 2.3 线程池本身导致的异常

线程池本身导致的异常可能会导致程序的中断，如果程序必须依靠线程池才能完成对应功能，当线程池本身导致异常如上面演示的。那么是否处理异常都无关紧要。整个程序直接崩溃！但是线程池只是一个备选方案，可以将可能的异常进行捕获处理。(但是不能完全杜绝让程序崩溃的问题)

  





