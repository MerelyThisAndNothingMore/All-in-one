---
tags: 
alias:
---
https://www.jianshu.com/p/37370c1d17fc

# [[Input触控事件处理]]

# 应用程序创建和启动
![](https://gd-hbimg.huaban.com/6ed5ce04b6586ffa92d944d83b293535a67b87aee6fc-Cl4LRw)
应用程序的启动过程其实就是根[[Activity]]的启动过程。
## Launcher进程请求[[AMS]]
桌面进程收到 input 触控事件并处理后 [[Binder]] 调用框架 AMS 的的 startActivity 接口启动应用

点击图标发生在 Launcher 应用的进程,实际上执行的是 Launcher 的 onClick 方法，在 onClick 里面会执行到 Activity 的 startActivity 方法。 startActivity 会调用 mInstrumentation.execStartActivity(); execStartActivity 通过 ActivityManager 的 getService 方法来得到 AMS 的代理对象

( Launcher 进程作为客户端与服务端 AMS 不在同一个进程, ActivityManager.getService 返回的是 IActivityManager.Stub 的代理对象,此 时如果要实现客户端与服务端进程间的通信， 需要 AMS 继承 IActivityManager.Stub 类并实现相应的方法,这样 Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了)

[[AMS|AMS]] 在[[system_server进程|system_server进程]]中。
## [[AMS|AMS]] pause 桌面应用
AMS 中的 [[Activity]] 栈管理的逻辑，检查发现当前处于前台 Resume 状态的 Activity 是桌面应用，所以第一步需要通知桌面应用的 Activity 进入 Paused 状态


## [[AMS]]发送创建应用进程请求
AMS 这边收到应用的 activityPaused 调用后，继续执行启动应用的逻辑，判断需要启动的应用 Activity 所在的进程不存在，所以接下来需要先 startProcessAsync 创建应用进程

Android 系统中一般应用进程的创建都是统一由 [[zygote进程]] fork 创建的，AMS 在需要创建应用进程时，会通过 [[socket]] 连接并通知到到 zygote 进程在开机阶段就创建好的 socket 服务端，然后由 zygote 进程 fork 创建出应用进程。

Zygote进程接受请求并fork[[app进程]]
AMS 通过 socket 通信告知 Zygote 进程 fork 子进程。

main方法中创建ApplicationThread，Looper，Handler 对象，并开启主线程消息循环Looper.loop()。
## 应用进程初始化
1. 应用进程默认的 java 异常处理机制（可以实现监听、拦截应用进程所有的 Java crash 的逻辑）；
    
2. JNI 调用启动进程的 binder 线程池（注意应用进程的 binder 线程池资源是自己创建的并非从 zygote 父进程继承的）；
    
3. 通过反射创建 [[Activity Thread]] 对象并调用其 “main” 入口方法。

进程 ActivityThread#main 函数初始化的主要逻辑是：

1. 创建并启动主线程的 loop 消息循环；
    
2. 通过 binder 调用 AMS 的 attachApplication 接口将自己 attach 注册到 AMS 中。

主线程初始化之后，主线程就有了完整的[[Looper]]、[[Message Queue]]、[[Handler]]。

主线程初始化完成后，主线程就进入阻塞状态，等待 Message，一旦有 Message 发过来，主线程就会被唤醒，处理 Message，处理完成之后，如果没有其他的 Message 需要处理，那么主线程就会进入休眠阻塞状态继续等待。可以说 Android 系统的运行是受消息机制驱动的，而整个消息机制是由上面所说的四个关键角色相互配合实现的（Handler、Looper、MessageQueue、Message）


## 发起attachApplication请求
[[app进程]]通过Binder(IActivityManager)向[[AMS]]([[system_server进程]]中)发起attachApplication请求,

AMS绑定ApplicationThread在 的 main 中,通过 ,将 AMS 绑定 ApplicationThread 对象,这样 AMS 就可以通过这个代理对象 来控制应用进程。

## 发送scheduleLaunchActivity
[[system_server进程|system_server进程]] 在收到请求后，进行一系列准备工作后，再通过 [[Binder]] ([[ApplicationThread|ApplicationThread]])向[[app进程]]发送scheduleLaunchActivity 请求; 

## ApplicationThread
App 进程的 binder 线程( ApplicationThread )在收到请求后，通过 handler 向主线程发送 LAUNCH_ACTIVITY 消息;

## [[Activity Thread]]的Handler处理LAUNCHER_ACTIVITY

主线程在收到 Message 后，handleLaunchActivity()，通过反射机制创建目标 Activity ，并回调 Activity.onCreate() 等方法。 

到此， App 便正式启动，开始进入 Activity 生命周期，执行完 onCreate/onStart/onResume 方法， UI 渲染结束后便可以看到 App 的主界面。


# 一对 AIDL 双向通讯  
IApplicationThread 和 IActivityManager 是一对配套的 AIDL 接口

-   IActivityManager 负责 Activity -> ActivityManagerService 的通讯
-   IApplicationThread 负责 ActivityManagerService -> Activity 的通讯
-   双向通讯的绑定是在 Activity 拿到同 ActivityManagerService 通讯的 AIDL 时把自己的 IApplicationThread 也就是反向 AIDL 接口交给 ActivityManagerService ，这样2者形成 AIDL 双向通讯






