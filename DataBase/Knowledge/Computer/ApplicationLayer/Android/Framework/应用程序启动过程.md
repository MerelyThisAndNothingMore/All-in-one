---
tags: 
alias:
---
![](https://gd-hbimg.huaban.com/6ed5ce04b6586ffa92d944d83b293535a67b87aee6fc-Cl4LRw)



应用程序的启动过程其实就是根[[Activity]]的启动过程。
1.Launcher进程请求AMS

点击图标发生在 Launcher 应用的进程,实际上执行的是 Launcher 的 onClick 方法，在 onClick 里面会执行到 Activity 的 startActivity 方法。 startActivity 会调用 mInstrumentation.execStartActivity(); execStartActivity 通过 ActivityManager 的 getService 方法来得到 AMS 的代理对象( Launcher 进程作为客户

端与服务端 AMS 不在同一个进程, ActivityManager.getService 返回的是 IActivityManager.Stub 的代理对象,此 时如果要实现客户端与服务端进程间的通信， 需要 AMS 继承 IActivityManager.Stub 类并实现相应的方法,这样 Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了)

2. AMS发送创建应用进程请求，Zygote进程接受请求并fork应用进程 AMS 通过 socket 通信告知 Zygote 进程 fork 子进程。

应用进程启动 ActivityThread ,执行 ActivityThread 的 main 方法。 main方法中创建ApplicationThread，Looper，Handler 对象，并开启主线程消息循环Looper.loop()。

3.App进程通过Binder向AMS(sytem_server)发起attachApplication请求,AMS绑定ApplicationThread
在 的 main 中,通过 ,将 AMS 绑定 ApplicationThread 对象,这样 AMS 就可以通过这个代理对象 来控制应用进程。

4.AMS发送启动Activity的请求  
system_server 进程在收到请求后，进行一系列准备工作后，再通过 binder 向App进程发送

scheduleLaunchActivity 请求; AMS 将启动 Activity 的请求发送给 ActivityThread 的 Handler 。 5.ActivityThread的Handler处理启动Activity的请求

App 进程的 binder 线程( ApplicationThread )在收到请求后，通过 handler 向主线程发送 LAUNCH_ACTIVITY 消息; 主线程在收到 Message 后，通过发射机制创建目标 Activity ，并回调 Activity.onCreate() 等方法。 到此， App 便正式启动，开始进入 Activity 生命周期，执行完 onCreate/onStart/onResume 方法， UI 渲染结束后便可以看到 App 的主界面。




1. [[Launcher进程|Launcher]]启动[[AMS]]
2. [[AMS]]到[[ApplicationThread]]
3. [[Activity Thread]]启动[[Activity]]
4. 

