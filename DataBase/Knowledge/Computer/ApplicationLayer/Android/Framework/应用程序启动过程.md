---
tags: 
alias:
---
https://www.jianshu.com/p/37370c1d17fc


# 启动流程
![](https://gd-hbimg.huaban.com/6ed5ce04b6586ffa92d944d83b293535a67b87aee6fc-Cl4LRw)
应用程序的启动过程其实就是根[[Activity]]的启动过程。
## Launcher进程请求AMS

点击图标发生在 Launcher 应用的进程,实际上执行的是 Launcher 的 onClick 方法，在 onClick 里面会执行到 Activity 的 startActivity 方法。 startActivity 会调用 mInstrumentation.execStartActivity(); execStartActivity 通过 ActivityManager 的 getService 方法来得到 AMS 的代理对象

( Launcher 进程作为客户端与服务端 AMS 不在同一个进程, ActivityManager.getService 返回的是 IActivityManager.Stub 的代理对象,此 时如果要实现客户端与服务端进程间的通信， 需要 AMS 继承 IActivityManager.Stub 类并实现相应的方法,这样 Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了)

[[AMS|AMS]] 在[[system_server进程|system_server进程]]中。
## [[AMS]]发送创建应用进程请求
Zygote进程接受请求并fork[[app进程]]
AMS 通过 socket 通信告知 Zygote 进程 fork 子进程。

[[app进程]]启动 ActivityThread ,执行 ActivityThread 的 main 方法。 
main方法中创建ApplicationThread，Looper，Handler 对象，并开启主线程消息循环Looper.loop()。

## 发起attachApplication请求
[[app进程]]通过Binder(IActivityManager)向[[AMS]]([[system_server进程]]中)发起attachApplication请求,

AMS绑定ApplicationThread在 的 main 中,通过 ,将 AMS 绑定 ApplicationThread 对象,这样 AMS 就可以通过这个代理对象 来控制应用进程。

## 发送scheduleLaunchActivity
[[system_server进程|system_server进程]] 在收到请求后，进行一系列准备工作后，再通过 [[Binder]] ([[ApplicationThread|ApplicationThread]])向[[app进程]]发送scheduleLaunchActivity 请求; 

## ApplicationThread
App 进程的 binder 线程( ApplicationThread )在收到请求后，通过 handler 向主线程发送 LAUNCH_ACTIVITY 消息;

## [[Activity Thread]]的Handler处理LAUNCHER_ACTIVITY

主线程在收到 Message 后，handleLaunchActivity()，通过反射机制创建目标 Activity ，并回调 Activity.onCreate() 等方法。 

到此， App 便正式启动，开始进入 Activity 生命周期，执行完 onCreate/onStart/onResume 方法， UI 渲染结束后便可以看到 App 的主界面。


# 一对 AIDL 双向通讯  
IApplicationThread 和 IActivityManager 是一对配套的 AIDL 接口

-   IActivityManager 负责 Activity -> ActivityManagerService 的通讯
-   IApplicationThread 负责 ActivityManagerService -> Activity 的通讯
-   双向通讯的绑定是在 Activity 拿到同 ActivityManagerService 通讯的 AIDL 时把自己的 IApplicationThread 也就是反向 AIDL 接口交给 ActivityManagerService ，这样2者形成 AIDL 双向通讯






