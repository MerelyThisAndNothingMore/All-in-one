---
tags: 
alias:
---
# 储备知识
## Android Dex 分包方案
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS04ZTcxMTlmMzgyMzQyOTI0LnBuZw)
## 类加载机制
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0zOGIwMzM3ZTg0MTg2YjBhLnBuZw)
# 原理
Android框架中存在一个数组，它的作用是维护全部的dex文件（我们写的类的二进制表述方式，用来给安卓虚拟机加载），安卓虚拟机会根据需要从该数组按照自上而下的顺序加载对应的类文件，即使数组中存多个同一个类对应的dex文件，虚拟机一旦找到了对应的dex文件就会停止查找，并加载。根据这个规则，我们只需要把Bug修复涉及到的类文件插入到数组的最前面去，就可以达到热修复的效果
## 具体描述

1. 把需修复、含`Bug`的类 独立打包到1个`Dex`文件中（记为：`patch.dex`）
2. 通过获取到当前应用的Classloader，即为BaseDexClassloader
3. 通过反射获取到他的DexPathList属性对象pathList
4. 通过反射调用pathList的dexElements方法把patch.dex转化为Element[]
5. 两个Element[]进行合并，把合并的fix.dex放到dexElements最前面去
6. 加载Element[]，达到修复目的


1.  把需修复、含`Bug`的类 独立打包到1个`Dex`文件中（记为：`patch.dex`）
2.  将该 `Dex`文件 插入到`ClassLoader`中集合 `dexElements`的最前面


