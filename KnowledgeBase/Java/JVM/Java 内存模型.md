---
tags: 
alias:
- JMM
- Java Memory Model
---
# 内存划分
-   `Java`虚拟机在运行`Java`程序时，会管理着一块内存区域：运行时数据区
-   在运行时数据区里，会根据用途进行划分：
    1.  [[Java 虚拟机栈]]
    2.  [[本地方法栈]]
    3.  [[Java 堆]]
    4.  [[方法区]]
    5.  程序计数器

## 程序计数器
程序计数器占用的内存空间比较小，可以看做是当前线程所指向的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支操作、循环操作、跳转、异常处理等也都需要依赖程序计数器。

-   在Java虚拟机规范中，程序计数器没有规定OutOfMemoryError的情况；
-   程序计数器是线程私有的，每个线程内部都有一个私有的程序计数器。它的生命周期是和线程的生命周期是同步的；
-   当一个线程正在执行一个Java方法的时候，这个程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法，则计数器值为空（Undefined）
## 虚拟机栈
虚拟机栈也是线程私有，生命周期与线程同步。在Java虚拟机规范中，虚拟机栈有两种异常情况：

-   StackOverflowError 当线程请求栈深度超出虚拟机栈所允许的深度时抛出
-   OutOfMemoryError 当Java虚拟机动态扩展到无法申请足够内存时抛出

JVM是基于栈的解释器执行的，DVM是基于寄存器解释器执行的。

上面这个栈就是指的虚拟机栈，虚拟机栈的初衷是用来描述Java方法执行的内存模型，**每个方法被执行的时候，JVM都会在虚拟机栈中创建一个栈帧**。
## [[本地方法栈|本地方法栈]] 
本地方法栈和虚拟机栈基本是相同的，只不过是针对native方法。
## 堆
Java堆是JVM所管理的内存中最大的一块，该区域唯一目的就是存放对象实例，几乎所有对象的实例都在堆里面分配，因此它也是Java垃圾收集器（GC）管理的主要区域，有时也叫GC堆。同时它也是所有线程共享的内存区域，因此被动态分配在此区域的对象如果被多个线程访问的话，需要考虑线程安全问题。

## 方法区
方法区：主要存储已经被JVM加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。该区域和堆一样，也是被各个线程共享的内存区域。

运行时常量池也是方法区中的，它用于存放编译期生成的各种字面量与符号引用。


成员变量:生命周期伴随类对象,类对象回收时回收 存在[[Java 堆]]里 

静态变量:不回收 在方法区 随着类的[[Java 类加载|加载]]而加载，随着类的消失而消失，由于类需要非常长时间的不使用，不利用，不关联，才有可能会被回收机制回收， 所以静态成员变量的生命周期特别长，除非是共享数据，否则不建议使用静态； 

局部变量:方法调用时创建 方法结束时被标记为可回收 存在[[Java 虚拟机栈]]里。



![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1mMzcwYjQ2ZjBkYjA3YmVlLnBuZw?x-oss-process=image/format,png)


![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NDQzNjUtMWM2Njk1MzIwMGU4MjUzZC5wbmc?x-oss-process=image/format,png)

