---
tags:
  - java
  - jvm
aliases:
  - Generational Collection
---

分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上:

1. 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。 
2. 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的[[垃圾收集器]]的一致的设计原则: 收集器应该将[[Java 堆]]划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。


## 算法思路
-   根据 **对象存活周期的不同** 将 `Java`堆内存 分为：新生代 & 老年代 。分配比例如下：
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hZWJhODAwYzljZDMxYjk5LnBuZw?x-oss-process=image/format,png)
- 根据 两块区域特点 选择 对应的垃圾收集算法
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01ZmRjNmI3YjM0NjcyZTVkLnBuZw?x-oss-process=image/format,png)
## 具体存储过程
新建的对象 一般会被优先分配到新生代的Eden区、From Survivor区
>大对象（如很长的字符串以及数组）会直接分配到老年代，这是为了避免在 Eden 区 和 Survivor区之间发生大量的内存复制（因为新生代会采用复制算法进行垃圾收集）

这些对象经过第一次 Minor GC后，若仍然存活，将会被移到To Survivor区
一次清理掉Eden、From Survivor区域

在 To Survivor 区每经过一轮 Minor GC ，该对象的年龄就+1
当对象年龄达到一定时(阈值默认=15)，就会被移动到老年代。
- 即新生代的对象在存活一定时间后，会被移动存储到老年代区域。
- 还有一种新生代对象被移懂到老年代区域的情况是：动态对象年龄判定。即如果在Survivor区中 所有相同年龄对象的大小总和大于Survivor区内存大小一半时，所有大于或等于该年龄的对象都会直接进入老年代。
### 特别注意
From Survivor 和 To Survivor之间会经常互换角色。

每次发生GC时，把Eden区和 From Survivor区中 存活且没超过年龄阈值的对象 复制到To Survivor区中（此时To Survivor变成了From Survivor），然后From Survivor清空（此时From Survivor变成了To Survivor）

## 总结
### 优点
效率高、空间利用率高

根据不同区域特点 选择 不同的垃圾收集算法

### 应用场景
现在主流的虚拟机基本都采用 分代收集算法 ，即根据不同区域特点选择不同垃圾收集算法。

新生代 区域：采用 复制算法
老年代 区域：采用 标记-清除 算法、标记 - 整理 算法


