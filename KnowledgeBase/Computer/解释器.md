---
tags: 
alias:
---





，解释器与编译器两者各有优势：

当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。当程序

启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少

解释器的中间损耗，获得更高的执行效率。当程序运行环境中[[内存]]资源限制较大，可以使用[[解释执行]]

节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编

译执行来提升效率。同时，解释器还可以作为编译器激进优化时后备的“逃生门”（如果情况允许，

[[HotSpot]]虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率

选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设

不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通

过逆优化（Deoptimization）退回到解释状态继续执行

## 分层编译