---
tags: 
alias:
---

[[Java 虚拟机]]以[[方法]]作为最基本的执行单元，“栈帧”(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的[[Java 虚拟机栈]]的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

一个[[线程]]中的方法调用链可能会很长，以[[Java]]程序的角度来看，同一时刻、同一条线程里面，在 调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”(Current Stack Frame)，与这个栈帧所关联的方法被称为“当前方法”(Current Method)。执行引擎所运行的所有[[字节码]]指令都只针对当前栈帧进行操作.

# 构成

## 局部变量表

局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义 的局部变量。在Java程序被编译为[[Class文件]]时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。

> 我们已经知道类的字段变量有两次赋初始值的过程，一次在[[Java 类加载#3.准备|准备]]阶段，赋予系统初始值;另外一次在初始化阶段，赋予程序员定义的初始值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值，不会产生歧义。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值，那它是完全不能使用的。所以不要认为 Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false等这样的默认值规则。

## 操作数栈

同局部变量表一样,操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占 的栈容量为1，64位数据类型所占的栈容量为2。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过 将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。

> Java虚拟机的解释执行引擎被称为“基于栈的执行引擎”，里面的“栈”就是操作数栈。

## 栈帧信息

在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。

