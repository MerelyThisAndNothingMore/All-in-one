---
tags: 
alias:
- Dynamic Programming
---
https://blog.csdn.net/weixin_43734095/article/details/105637149
-   是求解**最优化问题**的一种常用策略

通常的使用套路（一步一步优化）:  
① 暴力递归（**自顶向下**，出现了重叠子问题）  
② 记忆化搜索（**自顶向下**）  
③ 递推（**自底向上**）

① 定义状态（状态是原问题、子问题的解）
比如定义 d p ( i ) dp(i)dp(i) 的含义
② 设置初始状态（边界）
比如设置 d p ( 0 ) dp(0)dp(0) 的值
③ 确定状态转移方程
比如确定 d p ( i ) dp(i)dp(i) 和 d p ( i − 1 ) dp(i - 1)dp(i−1) 的关系




# 练习1：找零钱
dp(n) = min { dp(n - 25), dp(n - 20), dp(n - 5), dp(n - 1) } + 1
## 找零钱 - 暴力递归
```java
static int coins1(int n) {  
	// 递归基  
	if (n < 1) return Integer.MAX_VALUE;  
	if (n == 1 || n == 5 || n == 20 || n == 25) return 1;  
  
	// 找出四种取法的最小值  
	int min1 = Math.min(coins1(n - 25), coins1(n - 20));  
	int min2 = Math.min(coins1(n - 5), coins1(n - 1));  
	return Math.min(min1, min2) + 1;  
}
```
会有**大量的重复计算**，时间复杂度较高。
## 找零钱 - 记忆化搜索

## 找零钱 - 递推




# 扩展练习











