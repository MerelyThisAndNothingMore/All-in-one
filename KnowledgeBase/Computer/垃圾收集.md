---
tags: 
aliases:
  - GC
  - Garbage Collection
---
# 标记-清除 算法
## 算法思想
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0xZTBlMzU2ZDg5MmE5MGFlLnBuZw?x-oss-process=image/format,png)

算法分为两个阶段：
1.  标记阶段：标记出所有需要回收的对象；
2.  清除阶段：统一清除（回收）所有被标记的对象。
### 标记阶段
#### a. 可达性分析
##### GC Roots
1. 虚拟机栈帧(栈桢中的本地变量表)引用的对象、
2. 类静态属性引用的对象、
3. 常量引用的对象、
4. Native方法引用的对象 
-   Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NPE,OOM）等，还有系统类加载器
-   所有被同步锁（synchronized关键字）持有的对象
-   反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

对象若无 GC Roots引用，则表示可以被回收。

[[Java 引用类型]]：软引用SoftRef内存不足时回收，弱引用WeakRef发生gc时(内存即便充足)回收。
#### b. 第一次标记 & 筛选

##### 方式描述
对象 在 可达性分析中 被判断为不可达后，会被第一次标记 & 筛选

a. 不筛选 = 继续留在 ”即将回收“的集合里，准备被回收
b. 筛选 = 从 ”即将回收“的集合取出

##### 筛选的标准
该对象是否有必要执行 finalize()方法

若有必要执行（人为设置），则筛选出来，进入下一阶段：第二次标记 & 筛选；
若没必要执行，判断该对象死亡，不筛选 并等待回收
当对象无 finalize()方法 或 finalize()已被虚拟机调用过，则视为“没必要执行”
#### c. 第二次标记 & 筛选
当对象经过了第一次的标记 & 筛选，会被进行第二次标记，并被进行筛选

##### 方式描述
该对象会被放到一个 F-Queue 队列中，并由虚拟机自动建立、优先级低的Finalizer 线程去执行队列中该对象的finalize()

finalize()只会被执行一次
但并不承诺等待finalize()运行结束。这是为了防止 finalize()执行缓慢 / 停止 使得 F-Queue队列其他对象永久等待。
##### 判断标准
在执行finalize()过程中，若对象依然没与引用链上的GC Roots 直接关联 或 间接关联（即关联上与GC Roots 关联的对象），那么该对象将被判断死亡，不筛选（留在”即将回收“集合里） 并等待回收
## 总结
### 优点
算法简单、实现简单
### 缺点
-   效率问题：即 标记和清除 两个过程效率不高
-   空间问题：标记 - 清除后，会产生大量不连续的内存碎片。
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1lNDI0MjA2MjgyMjMwYjY1LnBuZw?x-oss-process=image/format,png)
这导致以后程序需要分配较大空间对象时无法找到足够大的连续内存 而被迫触发另外一次垃圾收集行为，非常浪费资源。

下面继续介绍的算法就是为了解决上述两个问题的。

### 应用场景
对象存活率较低 & 垃圾回收行为频率低的场景

如老年代区域，因为老年代区域回收频次少、回收数量少，所以对于效率问题 & 空间问题不会很明显。

# 复制算法
该算法的出现是为了解决 标记-清除算法中 效率 & 空间问题的。
## 算法思想
-   将内存分为大小相等的两块，每次使用其中一块；
-   当使用的这块内存用完，就将这块内存上还存活的对象 复制到另一块还没使用过的内存上
-   最终将使用的那块内存一次清理掉。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1mZjQ2MTk3ZmM2ZTdkMDE2LnBuZw?x-oss-process=image/format,png)
## 总结

### 优点
解决了标记-清除算法中 清除效率低的问题
每次仅回收内存的一半区域

解决了标记-清除算法中 空间产生不连续内存碎片的问题
将已使用内存上的存活对象 移动到栈顶的指针，按顺序分配内存即可。

### 缺点
每次使用的内存缩小为原来的一半。
当对象存活率较高的情况下需要做很多复制操作，即效率会变低
### 应用场景
对象存活率较低 & 需要频繁进行垃圾回收 的区域

如新生代区域

## 特别注意
### a. 背景
新生代区域在进行垃圾回收时，98%对象都必须得回收

### b. 问题
复制算法中 每次使用的内存缩小为原来的一半 利用率低 & 代价太高

### c. 解决方案

不 按 1：1的比例 划分内存，而是 按8：1：1比例 将内存划分为一块较大的 Eden 和两块较小的 Survivor 区域（From Survivor、To Survivor）
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0wNmZmZWNlZGMzZGE5YTMxLnBuZw?x-oss-process=image/format,png)
-   每次使用`Eden`、`From Survivor`区域；
-   用完后就 将上述两块区域存活的对象 复制到`To Survivor`区域上
-   最终一次清理掉`Eden`、`From Survivor`区域
- 
很多同学会问，假如 `Eden`、`From Survivor`区域上存活对象所需内存大小 > `To Survivor`区域怎么办？

解决方案：**依赖老年代内存区域 做 内存分配担保。**

> 即`To Survivor`区域 存不下来的对象 会通过 **内存分配担保机制** 暂时保存在老年代

# 标记 - 整理 算法
## 算法思路
算法分为三个阶段：

1.  标记阶段：标记出所有需要回收的对象；
2.  整理阶段：让所有存活的对象都向一端移动
3.  清除阶段：统一清除（回收）端以外的对象。

![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS02Yjg4MjI1YzUwMjgzZGJmLnBuZw?x-oss-process=image/format,png)
## 总结
### 优点
解决了标记-清除算法中 清除效率低的问题：一次清楚端外区域
解决了标记-清除算法中 空间产生不连续内存碎片的问题：将已使用内存上的存活对象 移动到栈顶的指针，按顺序分配内存即可。
### 应用场景
对象存活率较低 & 垃圾回收行为频率低 的场景

如老年代区域，因为老年代区域回收频次少、回收数量少，所以对于效率问题 & 空间问题不会很明显。

