---
tags: 
alias:
---

# 为什么要读这本书？

精进技术，开拓视野，提升思维。

# 收获是什么？

# 原文摘抄

## 序

> 编程是一种技艺。用最简单的话表述，编程可归结为让计算机做你(或你的用户)想要它做的事情。作为程序员，你既是倾听者，又是顾问;既是解释者，又是发号施令者。你设法捕捉难以捉摸的需求，并找到表达它们的方式，让一台纯粹的机器能够合理地处理它们。你设法为你的 工作建立文档，以使他人能够理解它;你还设法使你的工作工程化，以使他人能够以它为基础进 行构建。还有，你设法在项目时钟无休止的 “嘀嗒” 声的催迫下完成所有这些工作。你每天都在 创造小小的奇迹。
> 编程是艰难的工作。
> 
> 有许多人声称要给你帮助。工具供应商吹嘘它们的产品所展现出的奇迹。方法学古鲁(guru ) 允诺说他们的技术保证有效。每个人都声称他们的[[编程语言]]是最好的，而每一种操作系统都是对 所有可以想象得到的问题的解答。 当然，所有这些都不是真的。并不存在容易的答案。也不存在最佳解决方案这样 一种东西， 无论它是工具，是语言，还是操作系统。能够存在的只是在某些特定情形下更为适宜的系统。
> 
> 这正是注重实效 (pragmatism )登场的地方 。 你不应该局限于任何特定的技术 ， 而是应该拥有足够广博的背景和经验基础，以让你能在特定情况下选择好的解决方案。你的背景源自对计算 机科学的基本原理的理解，而你的经验来自广泛的实际项目。理论与实践的结合使你强大起来。
> 
> 你调整你的方法，以适应当前情形与环境。你判断对项目有影响的所有因素的相对重要性， 并利用你的经验制定适宜的解决方案。你随着工作的进展持续不断地进行这样的活动。注重实效 的程序员不仅要完成工作，而且要完成得漂亮。

本书是经验的集合，是工具箱。

## 第一章 注重实效的哲学

#### 我的源码让猫给吃了

> 在所有弱点中，最大的弱点就是害怕暴露弱点。
> 
> 依据你的职业发展、你的项目和你每天的工作，为你自己和你的行为负责这样 一种观念，是 注重实效的哲学的 一块基石。注重实效的程序员对他或她自己的职业生涯负责，并且不害怕承认 无知或错误。这肯定并非是编程最令人愉悦的方面，但它肯定会发生— 即使是在最好的项目中。 尽管有彻底的测试、良好的文档以及足够的自动化，事情还是会出错。交付晚了，出现了未曾预 见到的技术问题。 
> 
> 发生这样的事情，我们要设法尽可能职业地处理它们。这意味着诚实和坦率。我们可以为我 们的能力自豪，但对于我们的缺点——还有我们的无知和我们的错误——我们必须诚实。
> 
> 责任是你主动担负的东西。你承诺确保某件事情正确完成，但你不一定能直接控制事情的每一个方面。除了尽你所能以外，你必须分析风险是否超出了你的控制。对于不可能做到的事情或是风险太大的事情，你有权不去为之负责。你必须基于你自己的道德准则和判断来做出决定。
> 
> 如果你确实同意要为某个结果负责，你就应切实负起责任。当你犯错误(就如同我们所有人都 会犯错误一样)、或是判断失误时，诚实地承认它，并设法给出各种选择。不要责备别人或别的东 西，或是拼凑借又。不要把所有问题都归咎于供应商、编程语言、管理部门、或是你的同事。**也许他(它)们全体或是某几方在其中扮演了某种角色，但你可以选择提供解决方案，而非寻找借口。**

> Provide Options, Don't Make Lame Excuses.

#### 软件的熵

> 一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来 一种废弃感———种 职权部门不关心这座建筑的感觉。于是又一扇窗户破了。人们开始乱扔垃圾。出现了乱涂乱画。 严重的结构损坏开始了。在相对较短的一段时间里，建筑就被损毁得超出了业主愿意修理的程度， 而废弃感变成了现实。

> Don't Live with Broken Windows

> 不要留着“破窗户” (低劣的设计、错误决策、或是糟糕的代码)不修。发现一个就修一个。 如果没有足够的时间进行适当的修理，就用木板把它钉起来。或许你可以把出问题的代码放人注 释 ( commentout )， 或是显示 “ 未实现 ” 消息 ， 或是用虚设的数据 ( dummydata ) 加以替代 。 采 取某种行动防止进一步的损坏，并说明情势处在你的控制之下。
> 
> 如果你发现自己在有好些破窗户的项目里工作，会很容易产生这样的想法:“ 这些代码 的其余部分也是垃圾，我只要照着做就行了。” 项目在这之前是否一直很好，并没有什么关系。 在最初得出“破窗户理论” 的一项实验中，一辆废弃的轿车放了一个星期，无人理睬。而一旦有 一扇窗户被打破，数小时之内车上的设备就被抢夺一空，车也被翻了个底朝天。
#### 石头汤与煮青蛙

> 在有些情况下，你也许确切地知道需要做什么，以及怎样去做。整个系统就在你的眼前— 你知道它是对的。但请求许可去处理整个事情，你会遇到拖延和漠然。大家要设立委员会，预算 需要批准，事情会变得复杂化。每个人都会护卫他们自己的资源。有时候，这叫做“启动杂役”(start-up fatigue).
> 
> 这正是拿出石头的时候。设计出你可以合理要求的东西，好好开发它。一旦完成，就拿给大 家看，让他们大吃一惊。然后说:“要是我们增加...• 可能就会更好。”假装那并不重要。坐回椅 子上，等着他们开始要你增加你本来就想要的功能。人们发现，参与正在发生的成功要更容易。 让他们瞥见未来，你就能让他们聚集在你周围’。

> Be a Catalyst for Change 做变化的催化剂

> 另一方面，石头汤的故事也是关于温和而渐进的欺骗的故事。它讲述的是过于集中的注意力。 村民想着石头，忘了世界的其余部分。我们都是这样，每一天。事情会悄悄爬到我们身上。 
> 
> 我们都看见过这样的症状。项目慢慢地、不可改变地完全失去控制。大多数软件灾难都是从 微不足道的小事情开始的，大多数项目的拖延都是一天一天发生的。系统 一个特性一个特性地偏 离其规范，一个又—个的补丁被打到某段代码上，直到最初的代码 一点没有留下。常常是小事情 的累积破坏了士气和团队。
> 
> 不要像青蛙一样。留心大图景。要持续不断地观察周围发生的事情，而不只是你自己在做的 事情。

> Remember the Big Picture

#### 足够好的软件

> 你所制作的系统的范围和质量应该作为系统需求的一部分规定下来。

> 你常常会处在须要进行权衡的情形中 。 让人惊奇的是 ， 许多用户宁愿在今天用上有 一些 “ 毛 边” 的软件，也不愿等待 一年后的多媒体版本。许多预算吃紧的T部门都会同意这样的说法。 今天的了不起的软件常常比明天的完美软件更可取。如果你给用户某样东西，让他们及早使用， 他们的反馈常常会把你引向更好的最终解决方案

####  你的知识资产

> 你的知识和经验是你最重要的职业财富。 
> 
> 遗憾的是，它们是有时效的资产(expiringasset )’。随着新技术、语言及环境的出现，你的 知识会变得过时。不断变化的市场驱动力也许会使你的经验变得陈旧或无关紧要。考虑到 “网年” 飞逝的速度，这样的事情可能会非常快地发生。 
> 
> 随着你的知识的价值降低，对你的公司或客户来说，你的价值也在降低。我们想要阻止这样的事情，决不让它发生 。

> 我们喜欢把程序员所知道的关于计算技术和他们所工作的应用领域的全部事实、以及他们的所有经验视为他们的知识资产(KnowledgePortfolios)。管理知识资产与管理金融资产非常相似: 
> 
> 1. 严肃的投资者定期投资——作为习惯。
> 2. 多元化是长期成功的关键。
> 3. 聪明的投资者在保守的投资和高风险、高回报的投资之间平衡他们的资产。 
> 4. 投资者设法低买高卖，以获取最大回报。
> 5. 应周期性地重新评估和平衡资产。 
>
> 要在职业生涯中获得成功，你必须运用同样的指导方针管理你的知识资产。
> 
> 1. **定期投资**。就像金融投资一样，你必须定期为你的知识资产投资。即使投资量很小，习惯自身也和总量一样重要。
> 2. **多元化**。你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特定技术的各种特性。但不要就此止步。计算技术的面貌变化很快— —今天的热门技术明天就可能变得近乎无用(或至少是不再抢手)。你掌握的技术越多，你就越能更好地进行调整， 赶上变化 。
> 3. **管理风险** 。从高风险、可能有高回报，到低风险、低回报，技术存在于这样一条谱带上。把你所有的金钱都投入可能突然崩盘的高风险股票并不是一个好主意;你也不应太保守，错过可能的机会。不要把你所有的技术鸡蛋放在一个篮子里。
> 4. **低买高卖**。在新兴的技术流行之前学习它可能就和找到被低估的股票—样困难，但所得到的就和那样的股票带来的收益一样。在Java 刚出现时学习它可能有风险，但对于现在已步入该领域的顶尖行列的早期采用者，这样做得到了非常大的回报。
> 5. **重新评估和平衡**。这是 一个非常动荡的行业。你上个月开始研究的热门技术现在也许已像石 头一样冰冷。也许你需要重温你有一阵子没有使用的数据库技术。又或许，如果你之前试用 过另 一种语言，你就会更有可能获得那个新职位......

> Invest Regularly in Your Knowledge Portfolio 定期为你的知识资产投资

> 关于何时以及增加什么到你的知识资产中，现在你已经拥有了一些指导方针，那么什么是获得智力资本、从而为你的资产提供资金的最佳方式呢? 这里有一些建议。
> 
> 1. 每年至少学习一种新语言。不同语言以不同方式解决相同的问题。通过学习若干不同的方法， 可以帮助你拓宽你的思维，并避免墨守成规。此外，现在学习许多语言已容易了许多，感谢 可从网上自由获取的软件财富。
> 2. 每季度阅读一本技术书籍。书店里摆满了许多书籍，讨论与你当前的项目有关的有趣话题。 一旦你养成习惯，就一个月读一本书。在你掌握了你正在使用的技术之后，扩宽范围，阅读一些与你的项目无关的书籍。
> 3. 也要阅读非技术书籍。记住计算机是由人——你在设法满足其需要的人——使用的，这十分重要 。 不要忘了等式中人这一边 。
> 4. 上课。在本地的学院或大学、或是将要来临的下一次会展上寻找有趣的课程。
> 5. 参加本地用户组织。不要只是去听讲，而要主动参与。与世隔绝对你的职业生涯来说可能是致命的;打听一下你们公司以外的人都在做什么。
> 6. 试验不同的环境。如果你只在Windows上工作，就在家玩一玩Unix(可自由获取的Linux就正好)。 如果你只用过makefile和编辑器，就试一试IDE，反之亦然 。
> 7. 跟上潮流。订阅商务杂志和其他期刊。选择所涵盖的技术与你当前的项目不同的刊物。
> 8. 上网。想要了解某种新语言或其他技术的各种特性?要了解其他人的相关经验，了解他们使 用的特定行话，等等，新闻组是一种很好的方式。上网冲浪，查找论文、商业站点，以及其他任何你可以找到的信息来源。
>    
> 持续投入十分重要。一旦你熟悉了某种新语言或新技术，继续前进。学习另一种。
> 
> 如果你自己找不到答案，就去找出能找到答案的人。不要把问题搁在那里。与他人交谈可以 帮助你建立人际网络，而因为在这个过程中找到了其他不相关问题的解决方案，你也许还会让自己大吃一惊。旧有的资产也在不断增长...•
> 所有阅读和研究都需要时间，而时间已经很短缺。所以你需要预先规划。让自己在空闲的片 刻时间里总有东西可读。花在等医生上的时间是抓紧阅读的好机会——**但一定要带上你自己的杂志**，否则，你也许会发现自己在翻阅1973年的一篇卷角的关于巴布亚新几内亚的文章。

> Critically Analyze What You Read and Hear 批判地分析你读到的和听到的

#### 交流

> 问题不只是你有什么，还要看你怎样包装它。 除非你能够与他人交流，否则就算你拥有最好的主意、最漂亮的代码、或是最注重实效的想法， 最终也会毫无结果。没有有效的交流， 一个好想法就只是 一个无人关心的孤儿。
> 
> 作为开发者，我们必须在许多层面上进行交流。我们把许多小时花在开会、倾听和交谈上。 我们与最终用户一起工作，设法了解他们的需要。我们编写代码，与机器交流我们的意图;把我 们的想法变成文档，留给以后的开发者。我们撰写提案和备忘录，用以申请资源并证明其正当性、 报告我们的状态、以及提出各种新方法。我们每天在团队中工作，宣扬我们的主意、修正现有的 做法、并提出新的做法。我们的时间有很大 一部分都花在交流上，所以我们需要把它做好。
> 
> 知道你想要说什么
> 
> 规划你想要说的东西。写出大纲。然后问你自己:“这是否讲清了我要说的所有内容?” 提炼它，直到确实如此为止。这个方法不只适用于撰写文档。当你面临重要会议、或是要与重要客户通电话时，简略记下 <19 你想要交流的想法，并准备好几种把它们讲清楚的策略。

> 了解你的听众
> 
> 只有当你是在传达信息时，你才是在交流。为此，你需要了解你的听众的需要、兴趣、能力。我 们都曾出席过这样的会议: 一个做开发的滑稽人物在发表长篇独白，讲述某种神秘技术的各种优点， 把市场部副总裁弄得目光呆滞 。 这不是交流 ， 而只是空谈 ， 让人厌烦的 (a noying ” )空 谈 。 
> 要在脑海里形成 一幅明确的关于你的听众的画面。图1.1中显示的WISDOM离合 (acrostic) 可能会对你有帮助。
> 
  你想让他们学到什么? 
  他们对你讲的什么感兴趣?
  他们有多富有经验? 
  他们想要多少细节? 
  你想要让谁拥有这些信息? 
  你如何促使他们听你说话?

一个方案有多少好处？
这个问题的回答是列举因为这个方法而收益的人。

> 调整你的交流风格，让其适应你的听众。有人要的是正式的“事实” 简报。另 一些人喜欢在 进入正题之前高谈阔论 一番。如果是书面文档，则有人喜欢一大摞报告，而另 一些人却喜欢简单 的备忘录或电 子邮件。如果有疑问，就询问对方 。 
> 但是，要记住，你也是交流事务的一方。如果有人说，他们需要你用一段话进行描述，而你 觉得不用若干页纸就无法做到，如实告诉他们。记住，这样的反馈也是交流的 一种形式。

> It's Both What You Say and the Way You Say It 你说什么和你怎么说同样重要
> 除非你生活在真空中，你才不需要能交流。交流越有效，你就越有影响力。

> • 知道你想要说什么。 
> • 了解你的听众。
> • 选择时机。
> • 选择风格。
> • 让文档美观。 
> • 让听众参与。 
> • 做倾听者。
> • 回复他人

### 第二章 注重实效的途径

#### 重复的危害

> 代码失效。 作为程序员，我们收集、组织、维护和利用知识。我们在规范中记载知识、在运行的代码中 使其活跃起来并将其用于提供测试过程中所需的检查。
> 遗憾的是 ，知识并不稳定。它变化— 常常很快。你对需求的理解可能会随着与客户的会谈 而发生变化。政府改变规章制度，有些商业逻辑过时了。测试也许表明所选择的算法无法工作。 所有这些不稳定都意味着我们要把很大一部分时间花在维护上，重新组织和表达我们的系统中的 知识。

> DRY - Don't Repeat Yourself 不要重复你自己

> 我们所见到的大多数重复都可归人下列范畴:
> 1. 强加的重复 (imposedduplication )。 开发者觉得他们无可选择 — — 环境似乎要求重复 。 
> 2. 无意的重复 (inadvertent duplication)。开发者没有意识到他们在重复信息。
> 3. 无耐性的重复 (impatientduplication )。 开发者偷懒 ， 他们重复 ， 因为那样似乎更容易 。 
> 4. 开发者之间的重复 (interdeveloperduplication )。 同一团队 (或不同团队 )的 几个入重复 了同 样的信息。

> Make It Easy to Reuse 让复用变得容易

#### 正交性

> “正交性” 是从几何学中借来的术语。如果两条直线相交成直角， 它们就是正交的，比如图中的坐标轴。用向量术语说，这两条直线互不依赖。沿着某一条直线移动，你投影到另一条直线上的位置不变。
> 
> 在计算技术中，该术语用于表示某种不相依赖性或是解耦性。如果两个或更多事物中的一个 发生变化，不会影响其他事物，这些事物就是正交的。在设计良好的系统中，数据库代码与用户界面是正交的:你可以改动界面，而不影响数据库;更换数据库，而不用改动界面。

> 非正交系统的改变与控制更复杂是其固有的性质。当任何系统的各组件互相高度依赖时，就不再有局部修正 (localfix) 这样的事情 。
> 
> 我们想要设计自足 (s elf - contained ) 的组件 : 独立， 具有单一、良好定义的目的(Yourdon 和Constantine 称之为内聚(cohesion))。如果组件是相互隔离的，你就知道你能够改变 其中之一，而不用担心其余组件。只要你不改变组件的外部接口，你就可以放心 :你不会造成波及整个系统的问题。

> 你是否注意到，有些项目团队很有效率，每个人都知道要做什么，并全力做出贡献，而另一 些团队的成员却老是在争吵，而且好像无法避免互相妨碍?
> 这常常是 一个正交性问题。如果团队的组织有许多重叠，各个成员就会对责任感到困惑。每一次改动都需要整个团队开 一次会，因为他们中的任何 一个人都可能受到影响。
> 怎样把团队划分为责任得到了良好定义的小组，并使重叠降至最低呢?没有简单的答案。这 部分地取决于项目本身，以及你对可能变动的区域的分析。这还取决于你可以得到的人员。我们 的偏好是从使基础设施与应用分离开始。每个主要的基础设施组件(数据库、通信接又、中间件 层，等等)有自己的子团队。如果应用功能的划分显而易见，那就照此划分。然后我们考察我们 现 有 的 (或 计 划 有 的 ) 人 员 ， 并 对 分 组 进 行 相 应 的 调 整 。
> 你可以对项目团队的正交性进行非正式的衡量。只要看 一看，在讨论每个所需改动时需要涉 及多少人。人数越多，团队的正交性就越差。显然，正交的团队效率也更高(尽管如此，我们也鼓励子团队不断地相互交流)。

> 你可以将若干技术用于维持正交性:
> 1. 让你的代码保持解耦。编写“羞怯” 的代码— 也就是不会没有必要地向其他模块暴露任何 事情、也不依赖其他模块的实现的模块。试一试我们将在112页的 “解耦与得墨忒耳法则” 中 讨 论 的 得 墨 忒 耳 法 则 ( L a w o f D e m e t e r ) [L H 8 9 ] 。 如 果 你 需 要 改 变 对 象 的 状 态 ， 让 这 个 对 象替你去做。这样，你的代码就会保持与其他代码的实现的隔离，并增加你保持正交的机会。
> 2. 避免使用全局数据。每当你的代码引用全局数据时，它都把自己与共享该数据的其他组件绑 在 了 一起 。 即 使 你 只 想 对 全 局 数 据 进 行 读 取 ， 也 可 能 会 带 来 麻 烦 ( 例 如 ， 如 果 你 突 然 需 要 把 代码改为多线程的)。一般而言，如果你把所需的任何语境(cont ext )显式地传入模块，你 的代码就会更易于理解和维护。在面向对象应用中，语境常常作为参数传给对象的构造器。 换句话说，你可以创建含有语境的结构，并传递指向这些结构的引用。
> 3. 避免编写相似的函数。你常常会遇到看起来全都很像的 一组函数— 它们也许在开始和结束处共享公共的代码，中间的算法却各有不同。重复的代码是结构问题的 一种症状。要了解更 好 的 实 现 ， 参 见 《 设 计 模 式 》 一书 中 的 S t r a t e g y ( 策 略 ) 模 式 。

#### 可撤消性

> 工程师们喜欢问题有简单、单一的解决方案。与论述法国大革命的无数起因的 一篇模糊、热 烈的文章相比，允许你怀着极大的自信宣称x = 2 的数学测验要让人觉得舒服得多。管理人员往 往与工程师趣味相投:单 一、容易的答案正好可以放在电子表格和项目计划中。 现实世界能够合作就好了!遗憾的是，今天x是2，明天也许就需要是5，下周则是3。没有 什么永远不变——而如果你严重依赖某一事实，你几乎可以确定它将会变化。
> 
> 要实现某种东西，总有不止 一种方式，而且通常有不止 一家供应商可以提供第三方产品。如 果你参与的项目
> 被短视的、认为只有一种实现方式的观念所牵绊，你也许就会遇到让人不悦的意 外之事。

> There Are No Final Decisions 

> 通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。事实上，在我们做过的任何项 目中，我们都总能够这么做。

#### 曳光弹

> 曳光弹行之有效，是因为它们与真正的子弹在相同的环境、相同的约束下工作。它们快速飞 向目标，所以枪手可以得到即时的反馈。同时，从实践的角度看，这样的解决方案也更便宜。 
> 为了在代码中获得同样的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求。

> Use Tracer Bullets to Find the Target 用曳光弹找到目标

> 曳光代码并非用过就扔的代码:你编写它，是为了保留它。它含有任何一段产品代码都拥有 <50 ] 的完整的错误检查、结构、文档、以及自查。它只不过功能不全而已。但是，一旦你在系统的各组 件 间 实 现 了 端 到 端 (e n d - t o - e n d ) 的 连 接 ， 你 就 可 以 检 查 你 离 目 标 还 有 多 远 ， 并 在 必 要 的 情 况 下进行调整。一旦你完全瞄准，增加功能将是一件容易的事情。 
> 
> 曳光开发与项目永不会结束的理念是一致的:总有改动需要完成，总有功能需要增加。这是一个渐进的过程。

#### 原型与便笺


