---
aliases:
  - Deadlock
tags:
  - computerArchitecture
---

# 定义

死锁（Deadlock）是指两个或多个[[进程]]在执行过程中，因为竞争资源而造成的一种互相等待的现象。如果没有外力作用，这些进程将永远无法推进。死锁在[[操作系统]]和多线程编程中是一个常见的问题，可能导致系统资源的浪费和程序的卡死。

## 特点

1. **互斥**：每个资源只能被一个进程使用。
2. **占有并等待**：一个进程已占有至少一个资源，并请求新的资源，而这些资源被其他进程占有。
3. **不剥夺**：资源不能被强行从占有它的进程中剥夺，只能由进程自愿释放。
4. **循环等待**：存在一个进程集合，每个进程都在等待被另一个进程占有的资源，从而形成一个等待环路。

## 相似概念辨析

### 死锁 vs 饥饿

1. **死锁**：
   - **定义**：进程永远无法推进，资源被互相等待的进程循环占有。
   - **特征**：所有涉及的进程都停止执行，形成僵局。

2. **饥饿**：
   - **定义**：进程长时间得不到所需资源，但系统整体仍在运行。
   - **特征**：某些进程可能永远无法获得资源，而其他进程继续运行。

### 死锁 vs 活锁

1. **死锁**：
   - **定义**：进程永远无法推进，互相等待资源。
   - **特征**：进程完全停滞。

2. **活锁**：
   - **定义**：进程在尝试解决冲突时不断改变状态，但无法取得进展。
   - **特征**：进程虽然在运行，但没有实际进展。

# 原理

死锁的形成需要满足以下四个必要条件，称为“死锁的必要条件”：

1. **互斥条件**：资源不能同时被多个进程占用。
2. **占有并等待条件**：进程已经占有某些资源，同时等待其他资源。
3. **不剥夺条件**：资源不能被强行剥夺，只能由进程自愿释放。
4. **循环等待条件**：存在一个进程集合，每个进程都在等待被另一个进程占有的资源，形成一个等待环路。

### 示例：两个进程死锁

考虑两个进程 P1 和 P2，两个资源 R1 和 R2：

1. **P1** 占有 **R1**，请求 **R2**。
2. **P2** 占有 **R2**，请求 **R1**。

这时，**P1** 和 **P2** 都在等待对方释放资源，形成死锁。

# 使用

在并发编程和多进程系统中，死锁是一个需要特别注意的问题。以下是一些防止和解决死锁的方法：

1. **预防**：
   - **破坏互斥条件**：尽可能减少资源的独占性使用。
   - **破坏占有并等待条件**：在进程开始时一次性请求所有需要的资源。
   - **破坏不剥夺条件**：允许进程强制释放已占有的资源。
   - **破坏循环等待条件**：对资源进行有序编号，进程按顺序请求资源。

2. **避免**：
   - 使用银行家算法动态分配资源，确保系统始终处于安全状态。

3. **检测和恢复**：
   - 定期检测系统是否发生死锁，如果发现死锁，采取措施恢复系统，例如终止某些进程或强制剥夺资源。

4. **避免嵌套锁**：
   - 尽量避免在持有一个锁的同时请求另一个锁，使用更细粒度的锁或锁的顺序化。

### 示例：使用超时机制避免死锁

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

public class AvoidDeadlock {
    private final Lock lock1 = new ReentrantLock();
    private final Lock lock2 = new ReentrantLock();

    public void method1() {
        try {
            if (lock1.tryLock(1000, TimeUnit.MILLISECONDS)) {
                try {
                    // Simulate work
                    Thread.sleep(500);
                    if (lock2.tryLock(1000, TimeUnit.MILLISECONDS)) {
                        try {
                            // Perform task
                        } finally {
                            lock2.unlock();
                        }
                    } else {
                        // Handle timeout
                    }
                } finally {
                    lock1.unlock();
                }
            } else {
                // Handle timeout
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void method2() {
        try {
            if (lock2.tryLock(1000, TimeUnit.MILLISECONDS)) {
                try {
                    // Simulate work
                    Thread.sleep(500);
                    if (lock1.tryLock(1000, TimeUnit.MILLISECONDS)) {
                        try {
                            // Perform task
                        } finally {
                            lock1.unlock();
                        }
                    } else {
                        // Handle timeout
                    }
                } finally {
                    lock2.unlock();
                }
            } else {
                // Handle timeout
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

在这个示例中，`tryLock` 方法尝试获取锁，如果无法在指定时间内获取锁，则避免进入死锁状态。

# Q & A

**Q1: 为什么死锁是个严重的问题？**

A1: 死锁会导致系统资源的浪费和程序的停滞，进程无法继续执行，严重影响系统的可靠性和可用性。

**Q2: 如何检测系统中是否存在死锁？**

A2: 通过构建资源分配图并检查是否存在循环，可以检测死锁。也可以使用系统日志和监控工具来发现死锁。

**Q3: 死锁和线程安全有何关系？**

A3: 死锁是[[线程安全]]问题的一种，涉及多个[[线程]]和资源的竞争。实现线程安全时需要考虑避免死锁。

**Q4: 如何使用银行家算法避免死锁？**

A4: 银行家[[算法]]通过模拟资源分配，确保系统始终处于安全状态。只有在资源分配后系统仍然安全时，才允许分配资源。

**Q5: 在实际开发中，如何避免死锁？**

A5: 实际开发中可以通过设计良好的锁策略、使用超时机制、避免嵌套锁和严格的代码审查等方法来避免死锁。