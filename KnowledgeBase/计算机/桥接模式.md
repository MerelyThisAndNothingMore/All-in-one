---
tags: 
aliases:
  - Bridge Pattern
---

# 定义

桥接模式（Bridge Pattern）是结构型[[设计模式]]之一，它的核心思想是将抽象部分与实现部分分离，使它们可以独立地变化。通过使用桥接模式，程序的抽象和具体实现之间的耦合度降低，从而提高了系统的灵活性和扩展性。

## 特点

1. **解耦抽象和实现**：
   - 桥接模式将抽象部分和实现部分分离，使它们可以独立变化和扩展。

2. **提高扩展性**：
   - 抽象和实现可以独立扩展，增加新的抽象部分或实现部分不会影响已有的代码。

3. **灵活性高**：
   - 桥接模式通过[[组合]]而非[[继承]]来实现功能的扩展，使得不同的实现可以在运行时动态组合。

4. **遵循开闭原则**：
   - 通过桥接模式，可以在不修改已有代码的情况下，增加新的功能或实现，符合开闭原则。

## 相似概念辨析

1. **桥接模式 vs. 适配器模式（Adapter Pattern）**：
   - 适配器模式用于将一个接口转换为另一个接口，使得不兼容的接口可以协同工作。桥接模式则是将抽象与实现分离，从一开始就设计成可独立变化的两个部分。

2. **桥接模式 vs. 组合模式（Composite Pattern）**：
   - 组合模式用于将对象组合成树形结构，以表示“部分-整体”的层次结构。桥接模式则是将抽象和实现分离，不涉及层次结构。

3. **桥接模式 vs. 策略模式（Strategy Pattern）**：
   - 策略模式用于在运行时选择[[算法]]的实现。桥接模式关注的是抽象和实现的分离，提供了更广泛的灵活性。

# 原理

桥接模式通过将抽象部分和实现部分分离，使它们可以独立变化。主要包括以下几个部分：

1. **抽象（Abstraction）**：
   - 定义了抽象接口，持有一个实现部分的引用。

2. **细化抽象（Refined Abstraction）**：
   - 扩展抽象接口，增加特定的功能。

3. **实现（Implementor）**：
   - 定义了实现[[接口]]，提供抽象部分所需的具体操作。

4. **具体实现（Concrete Implementor）**：
   - 实现实现接口的具体[[类]]。

# 使用

桥接模式适用于以下场景：

1. **希望抽象和实现可以独立扩展而不互相影响**。
2. **不希望在抽象和具体实现之间有紧密耦合**。
3. **希望通过组合不同的实现，来实现不同的行为**。

## 示例

假设我们要实现一个图形绘制程序，可以绘制不同类型的形状（如圆形、矩形），并且可以使用不同的绘制工具（如像素绘制、矢量绘制）。

### Java 示例

1. **定义实现接口**：

```java
public interface DrawAPI {
    void drawCircle(int radius, int x, int y);
    void drawRectangle(int width, int height, int x, int y);
}
```

2. **实现具体实现类**：

```java
public class PixelDrawAPI implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Drawing Circle [Pixel] with radius " + radius + " at (" + x + ", " + y + ")");
    }

    @Override
    public void drawRectangle(int width, int height, int x, int y) {
        System.out.println("Drawing Rectangle [Pixel] with width " + width + " and height " + height + " at (" + x + ", " + y + ")");
    }
}

public class VectorDrawAPI implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Drawing Circle [Vector] with radius " + radius + " at (" + x + ", " + y + ")");
    }

    @Override
    public void drawRectangle(int width, int height, int x, int y) {
        System.out.println("Drawing Rectangle [Vector] with width " + width + " and height " + height + " at (" + x + ", " + y + ")");
    }
}
```

3. **定义抽象类**：

```java
public abstract class Shape {
    protected DrawAPI drawAPI;

    protected Shape(DrawAPI drawAPI) {
        this.drawAPI = drawAPI;
    }

    public abstract void draw();
}
```

4. **实现细化抽象类**：

```java
public class Circle extends Shape {
    private int radius, x, y;

    public Circle(int radius, int x, int y, DrawAPI drawAPI) {
        super(drawAPI);
        this.radius = radius;
        this.x = x;
        this.y = y;
    }

    @Override
    public void draw() {
        drawAPI.drawCircle(radius, x, y);
    }
}

public class Rectangle extends Shape {
    private int width, height, x, y;

    public Rectangle(int width, int height, int x, int y, DrawAPI drawAPI) {
        super(drawAPI);
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
    }

    @Override
    public void draw() {
        drawAPI.drawRectangle(width, height, x, y);
    }
}
```

5. **使用桥接模式**：

```java
public class BridgePatternDemo {
    public static void main(String[] args) {
        Shape pixelCircle = new Circle(10, 100, 100, new PixelDrawAPI());
        Shape vectorRectangle = new Rectangle(20, 30, 50, 50, new VectorDrawAPI());

        pixelCircle.draw();
        vectorRectangle.draw();
    }
}
```

### Kotlin 示例

1. **定义实现接口**：

```kotlin
interface DrawAPI {
    fun drawCircle(radius: Int, x: Int, y: Int)
    fun drawRectangle(width: Int, height: Int, x: Int, y: Int)
}
```

2. **实现具体实现类**：

```kotlin
class PixelDrawAPI : DrawAPI {
    override fun drawCircle(radius: Int, x: Int, y: Int) {
        println("Drawing Circle [Pixel] with radius $radius at ($x, $y)")
    }

    override fun drawRectangle(width: Int, height: Int, x: Int, y: Int) {
        println("Drawing Rectangle [Pixel] with width $width and height $height at ($x, $y)")
    }
}

class VectorDrawAPI : DrawAPI {
    override fun drawCircle(radius: Int, x: Int, y: Int) {
        println("Drawing Circle [Vector] with radius $radius at ($x, $y)")
    }

    override fun drawRectangle(width: Int, height: Int, x: Int, y: Int) {
        println("Drawing Rectangle [Vector] with width $width and height $height at ($x, $y)")
    }
}
```

3. **定义抽象类**：

```kotlin
abstract class Shape(protected val drawAPI: DrawAPI) {
    abstract fun draw()
}
```

4. **实现细化抽象类**：

```kotlin
class Circle(
    private val radius: Int,
    private val x: Int,
    private val y: Int,
    drawAPI: DrawAPI
) : Shape(drawAPI) {
    override fun draw() {
        drawAPI.drawCircle(radius, x, y)
    }
}

class Rectangle(
    private val width: Int,
    private val height: Int,
    private val x: Int,
    private val y: Int,
    drawAPI: DrawAPI
) : Shape(drawAPI) {
    override fun draw() {
        drawAPI.drawRectangle(width, height, x, y)
    }
}
```

5. **使用桥接模式**：

```kotlin
fun main() {
    val pixelCircle: Shape = Circle(10, 100, 100, PixelDrawAPI())
    val vectorRectangle: Shape = Rectangle(20, 30, 50, 50, VectorDrawAPI())

    pixelCircle.draw()
    vectorRectangle.draw()
}
```

通过这些示例，可以看到桥接模式如何将抽象和实现分离，使得它们可以独立变化和扩展，从而提高代码的灵活性和可维护性。