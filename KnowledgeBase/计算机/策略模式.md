---
tags: 
aliases:
  - Strategy Pattern
---

## 定义

**策略模式**（Strategy Pattern）是一种行为设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以互相替换。策略模式使得算法可以独立于使用它的客户端变化。换句话说，策略模式允许在运行时选择不同的算法或行为，而无需修改客户端的代码。

使用策略模式时，将一个策略类作为参数传递给客户端，客户端根据不同的策略对象执行不同的算法。

## 特点

- **封装变化**：将不同的算法封装在不同的类中，使得算法可以独立地变化，而不影响使用它的代码。
- **可扩展性**：通过增加新的策略类，可以方便地扩展算法，而不需要修改现有代码。
- **运行时动态行为**：可以根据运行时的条件选择不同的策略对象，从而实现动态行为的切换。

## 相似概念辨析

### 策略模式 vs 状态模式
- **策略模式**：策略模式的目标是让算法在运行时可互换，通常由客户端选择合适的策略。
- **状态模式**：状态模式则是通过对象的内部状态来决定行为，状态模式中的状态转换是自动的，通常不需要外部干预。

### 策略模式 vs 模板方法模式
- **策略模式**：通过组合来选择不同的算法或行为。
- **模板方法模式**：通过继承来定义算法的框架，并允许子类提供不同的实现。

### 策略模式 vs 工厂模式
- **策略模式**：用于选择和封装算法。
- **工厂模式**：用于创建对象。

## 原理

策略模式的核心在于将算法的实现独立于客户端，通过定义一个**策略接口**，所有不同的算法实现都必须遵循这个接口，然后客户端通过引用接口类型的对象来调用具体的算法。这样，客户端无需关心具体的算法实现，而只需要知道策略接口。

### 策略模式的结构

1. **Context（上下文类）**：持有策略对象的引用，调用具体的策略方法。
2. **Strategy（策略接口）**：定义了算法的通用接口。
3. **ConcreteStrategy（具体策略）**：实现了策略接口的具体算法。

```kotlin
// 策略接口
interface Strategy {
    fun execute(a: Int, b: Int): Int
}

// 具体策略1：加法
class AddStrategy : Strategy {
    override fun execute(a: Int, b: Int): Int = a + b
}

// 具体策略2：减法
class SubtractStrategy : Strategy {
    override fun execute(a: Int, b: Int): Int = a - b
}

// 上下文类
class Context(private val strategy: Strategy) {
    fun executeStrategy(a: Int, b: Int): Int {
        return strategy.execute(a, b)
    }
}

// 使用策略模式
fun main() {
    val addContext = Context(AddStrategy())
    println("加法: ${addContext.executeStrategy(5, 3)}")

    val subtractContext = Context(SubtractStrategy())
    println("减法: ${subtractContext.executeStrategy(5, 3)}")
}
```

在这个例子中，`Strategy`接口定义了一个通用的操作`execute()`，具体策略`AddStrategy`和`SubtractStrategy`分别实现了加法和减法操作。客户端通过`Context`类调用不同的策略，而不需要了解算法的细节。

## 使用

### 1. 策略模式的典型场景
- **不同算法的选择**：在需要根据条件选择不同算法或操作时，比如排序算法（快速排序、归并排序等）。
- **替换复杂的条件语句**：当代码中有大量的`if-else`或`switch`语句用于选择不同的行为时，可以考虑使用策略模式来代替。
- **运行时动态变化**：当行为或算法在程序运行过程中需要灵活切换时，比如支付方式、优惠策略等。

### 2. 实际应用
- **Java中的Comparator接口**：在排序中使用不同的比较器来定义不同的排序规则，正是策略模式的应用。
- **支付系统**：可以根据不同的支付方式（微信、支付宝、信用卡）使用不同的策略实现支付处理。

## Q & A

### 1. **什么时候应该使用策略模式？**
   当你的代码中有多个算法或行为可以选择，并且它们之间可以互换时，策略模式是合适的解决方案。

### 2. **策略模式的缺点是什么？**
   策略模式的主要缺点是增加了策略类的数量，如果有很多策略，会导致类的数量迅速增加，增加代码复杂度。

### 3. **策略模式如何与依赖注入一起使用？**
   通过依赖注入框架（如Spring），可以动态注入不同的策略实现，而不需要在代码中手动创建策略对象，这使得策略模式的使用更加灵活。

## 总结

**策略模式**是一种行为设计模式，主要用于封装不同的算法，并使它们可以互相替换。它可以提高代码的灵活性和扩展性，尤其在需要根据不同情况动态选择算法的场景下。策略模式遵循开闭原则，能够轻松扩展新的策略而无需修改已有代码，但也可能增加类的数量和复杂性。
