---
tags: 
alias:
- Coroutine
---
https://blog.csdn.net/LeeDuoZuiShuai/article/details/125961337
https://juejin.cn/post/6953441828100112392#heading-16
https://juejin.cn/post/6950616789390721037
https://juejin.cn/post/6854573211418361864
https://juejin.cn/post/6844904057530908679

# 介绍

由于最初多数的用户线程是被设计成协同式调度 (Cooperative Scheduling)的，所以它有了一个别名——“协程”(Coroutine)。又由于这时候的协程会 完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”(Stackfull Coroutine)，起这样的 名字是为了便于跟后来的“无栈协程”(Stackless Coroutine)区分开。无栈协程不是本节的主角，不过 还是可以简单提一下它的典型应用，即各种语言中的await、async、yield这类关键字。无栈协程本质上 是一种有限状态机，状态保存在闭包里，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有 限。

协程是轻量级的[[线程|线程]]，它的轻量级体现在启动和切换：协程的启动不需要申请额外的堆栈空间；协程的切换发生在用户态，而非内核态。
它**基于[[Java 线程池]]API**。

## 原理
### 续体传递
续体传递风格(Continuation-Passing-Style)，本质上是代码的回调与结果的传递。
### 状态机
协程的代码在经过编译器处理时会被优化为状态机模型，每段代码有三个状态：未执行、挂起、已恢复。
## 核心概念
### 协程作用域
协程作用域用于管理作用域内协程的生命周期
```kotlin
interface CoroutineScope { 
	// 作用域内启动协程的默认上下文 
	val coroutineContext: CoroutineContext 
}
```
协程中提供了两个常用的方法来创建新的协程作用域：coroutineScope和supervisorScope。当子协程取消或发生异常时，在coroutineScope下，会导致父协程被取消，而在supervisorScope作用域下，则不会影响父协程。

### 协程调度器
协程调度器用于切换执行协程的线程，常见的调度器有以下四种：
- Dispatchers.Default：默认调度器。它使用JVM的共享线程池，该调度器的最大并发度是CPU的核心数，默认为2。
- Dispatchers.Unconfined：非受限调度器。该调度器不会限制代码在指定的线程上执行。即挂起函数后面的代码不会主动恢复到挂起之前的线程去执行，而是在执行挂起函数的线程上执行。
- Dispatchers.IO：IO调度器。它将阻塞的IO任务分流到一个共享的线程池中。该调度器和Dispatchers.Default共享线程。
- Dispatchers.Main：主线程调度器。一般用于操作与更新UI。

### 协程的启动模式

协程的作用域有三种，他们分别是：

- `runBlocking`：顶层函数，它和 `coroutineScope` 不一样，它会阻塞当前线程来等待，所以这个方法在业务中并不适用 。
- `GlobalScope`：全局协程作用域，可以在整个应用的声明周期中操作，且不能取消，所以仍不适用于业务开发。
- 自定义作用域：自定义协程的作用域，不会造成内存泄漏。

显然，我们不能在 `Activity` 中调用 `GlobalScope`




