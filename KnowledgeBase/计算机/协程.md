---
tags: 
alias:
- Coroutine
---
https://blog.csdn.net/LeeDuoZuiShuai/article/details/125961337
https://juejin.cn/post/6953441828100112392#heading-16
https://juejin.cn/post/6950616789390721037
https://juejin.cn/post/6854573211418361864
https://juejin.cn/post/6844904057530908679



# 定义

协程是Coroutine的中文简称，co表示协同、协作，routine表示程序。协程可以理解为多个互相协作的程序。协程是轻量级的[[线程]]，它的轻量体现在启动和切换，协程的启动不需要申请额外的堆栈空间；协程的切换发生在用户态，而非内核态，避免了复杂的系统调用。协程基于线程池API

## 特点

1. 更加轻量级，占用资源更少。  
2. 避免“回调地狱”，增加代码可读性。  
3. 协程的挂起不阻塞线程。

## 核心概念

### 协程上下文

协程上下文是一组可以附加到协程中的[[持久化]]用户定义对象，代码如下：

```kotlin
interface CoroutineContext {
    // 重载"[]"操作
    operator fun <E : Element> get(key: Key<E>): E?
    // 单值归一化操作
    fun <R> fold(initial: R, operation: (R, Element) -> R): R
    // 重载 "+"操作
    operator fun plus(context: CoroutineContext): CoroutineContext
    // 获取当前指定key外的其他上下文
    fun minusKey(key: Key<*>): CoroutineContext

    interface Element : CoroutineContext {
        val key: Key<*>
    }

    interface Key<E : Element>
}
```

 Element接口[[继承]]自CoroutineContext接口，协程中的拦截器、调度器、异常处理器以及代表协程自身生命周期等重要的[[类]]，都实现了Element接口。

Element接口规定每个实现该[[接口]]的对象都要有一个独一无二的Key，以便在需要的时候可以在协程上下文中快速的找到。因此，协程上下文可以理解为是一个Element的索引集，一个结构介于Set和[[Map]]之间的索引集。

### 协程作用域

协程作用域用于管理作用域内协程的生命周期
```kotlin
interface CoroutineScope { 
	// 作用域内启动协程的默认上下文 
	val coroutineContext: CoroutineContext 
}
```

协程中提供了两个常用的[[方法]]来创建新的协程作用域：coroutineScope和supervisorScope。两种方法创建的作用域中的上下文会自动继承父协程的上下文。当子协程取消或发生异常时，在coroutineScope下，会导致父协程被取消，而在supervisorScope作用域下，则不会影响父协程。

### 协程调度器

协程调度器用于切换执行协程的线程，常见的调度器有以下四种：
- Dispatchers.Default：默认调度器。它使用[[Java 虚拟机|JVM]]的共享[[线程]]池，该调度器的最大[[并发]]度是[[CPU]]的核心数，默认为2。
- Dispatchers.Unconfined：非受限调度器。该调度器不会限制代码在指定的线程上执行。即挂起函数后面的代码不会主动恢复到挂起之前的线程去执行，而是在执行挂起函数的线程上执行。
- Dispatchers.IO：IO调度器。它将阻塞的IO任务分流到一个共享的线程池中。该调度器和Dispatchers.Default共享线程。
- Dispatchers.Main：主线程调度器。一般用于操作与更新UI。

### 协程的启动模式

协程的作用域有三种，他们分别是：

- `runBlocking`：顶层函数，它和 `coroutineScope` 不一样，它会阻塞当前线程来等待，所以这个方法在业务中并不适用 。
- `GlobalScope`：全局协程作用域，可以在整个应用的声明周期中操作，且不能取消，所以仍不适用于业务开发。
- 自定义作用域：自定义协程的作用域，不会造成内存泄漏。

显然，我们不能在 `Activity` 中调用 `GlobalScope`


# 使用

# 原理

Kotlin协程原理核心体现在“**续体传递**”与“**状态机**”两部分。

## 续体传递

  续体传递是一种代码编写风格——续体传递风格(Continuation-Passing-Style)，简称为CPS。续体传递本质上是代码的回调与结果的传递。假设将顺序执行代码分成两部分，第一部分执行完成，返回一个结果(可能为空、一个[[对象]]引用、一个具体的值)。接着通过回调执行第二部分代码，并传入第一部分代码返回的结果，这种形式的代码编写风格就是续体传递风格。

### 普通代码
```kotlin
fun calculate(a: Int, b: Int): Int = a + b

fun main() {
    val result = calculate(1, 2)
    Log.d("liduo",result)
}
```

### 续体传递风格代码
```kotlin
interface Continuation {
    fun next(result: Int)
}

fun calculate(a: Int, b: Int, continuation: Continuation) = 
    continuation.next(a + b)

fun main() {
    calculate(1, 2, object : Continuation {
    	override fun next(result: Int) {
        	Log.d("liduo", "$result")
        }
    })
}

```

两者的区别在于续体传递风格中，回调代码的执行由calculate方法内部决定。

## 状态机

 协程的代码在经过Kotlin编译器处理时，会被优化成状态机模型。每段代码有三个状态：未执行、挂起、已恢复(完成)。处于未执行状态的代码可以被执行，执行过程中发生挂起，会进入挂起状态，从挂起中恢复或执行完毕会进入已恢复(完成)状态。当多个像这样的代码进行协作时，可以组合出更复杂的状态机。
 
