---
tags: 
alias:
---

# 定义

[[互斥同步]]面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步。

从解决问题的方式看，互斥同步属于一种悲观的[[并发]]策略，其总是认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁），这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。随着硬件指令集的发展，现在有了另一个选择：基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施就是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步，使用这种措施的代码也被称为无锁编程。

# 特别说明

为什么笔者说使用乐观并发策略需要“硬件指令集的发展”?因为我们必须要求操作和冲突检测这 两个步骤具备原子性。靠什么来保证原子性?如果这里再使用互斥同步来保证就完全失去意义了，所 以我们只能靠硬件来实现这件事情，硬件保证某些从语义上看起来需要多次操作的行为可以只通过一 条处理器指令就能完成，这类指令常用的有:

· 测 试 并 设 置 ( T e s t - a n d - Se t ) ;  
· 获 取 并 增 加 ( F et ch - an d - I n cr emen t ) ;  
·交换(Swap);  
·比较并交换(Comp are-and-Swap，下文称CAS); ·加载链接/条件储存(Load-Linked/St ore-Condit ional，下文称LL/SC)。

其中，前面的三条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处 理器新增的，而且这两条指令的目的和功能也是类似的。在IA64、[[x86]]指令集中有用cmp xchg指令完成 的CAS功能，在SPARC-TSO中也有用casa指令实现的，而在ARM和PowerPC架构下，则需要使用一对 ldrex/s t rex指令来完成LL/SC的功能。因为J ava里最终暴露出来的是CA S操作，所以我们以CA S指令为例 进行讲解。
