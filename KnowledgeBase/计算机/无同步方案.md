---
tags: 
alias:
---

要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系。
同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自
然就不需要任何同步措施去保证其正确性，因此会有一些代码天生就是线程安全的，笔者简单介绍其
中的两类。

## 可重入代码(Reentrant Code)

这种代码又称纯代码(Pure Code)，是指可以在代码执行的任何 时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不 会出现任何错误，也不会对结果有所影响。在特指多线程的上下文语境里(不涉及信号量等因

素[6])，我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重 入性是更为基础的特性，它可以保证代码线程安全，即所有可重入的代码都是线程安全的，但并非所 有的线程安全的代码都是可重入的。

  可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，
用到的状态量都由参数中传入，不调用非可重入的方法等。我们可以通过一个比较简单的原则来判断
代码是否具备可重入性:如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返
回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。

线程本地存储(Thread Local Storage):如果一段代码中所需要的数据必须与其他代码共享，那就 看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可 见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会 将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中 的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得 很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。

J ava语言中，如果一个变量要被多线程访问，可以使用volat ile关键字将它声明为“ 易变的”;如果

一个变量只要被某个线程独享，Java中就没有类似C++中__declspec(thread)[7]这样的关键字去修饰，不 过我们还是可以通过java.lang.T hreadLocal类来实现线程本地存储的功能。每一个线程的T hread对象中都 有一个ThreadLocalM ap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线 程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalM ap的访问入口，每一个

T hreadLocal对象都包含了一个独一无二的t hreadLocalH as hCode值，使用这个值就可以在线程K -V值对 中找回对应的本地线程变量。

