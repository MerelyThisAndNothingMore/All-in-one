---
tags:
 - dataStructure 
alias:
 - Balanced Binary Search Tree
 - BBST
---

# 定义

平衡二叉搜索树（Balanced Binary Search Tree, BBST）是一种特殊类型的[[二叉搜索树]]，具有高度平衡的结构，以确保基本操作（如插入、删除和查找）的[[时间复杂度]]为 O(log n)。通过自动维护树的平衡性，平衡二叉搜索树避免了最坏情况下退化成链表的情况，从而提高了操作效率。

## 特点

1. **高度平衡**：
   - 平衡二叉搜索树始终保持平衡，即树的左右子树的高度差不超过一定的范围（通常为1）。

2. **快速查找**：
   - 由于树的高度是 O(log n)，查找操作可以在对数时间内完成。

3. **高效插入和删除**：
   - 插入和删除操作在保持树平衡的同时，复杂度为 O(log n)。

4. **自动调整**：
   - 在插入和删除操作后，通过旋转等操作自动维护树的平衡性。

# 原理

平衡二叉搜索树通过在插入和删除节点时进行调整（如旋转）来保持树的平衡。常见的平衡二叉搜索树有以下几种类型：

1. **[[AVL树]]**：
   - 每个节点存储一个平衡因子（左子树和右子树的高度差），在插入和删除时通过旋转保持平衡。

2. **[[红黑树]]**：
   - 一种自平衡二叉搜索树，每个节点额外存储一个颜色位，通过严格的平衡规则和旋转操作保持平衡。

3. **Splay 树**：
   - 一种自调整二叉搜索树，通过在每次访问节点后将其旋转到根节点来保持平衡。

4. **[[B树]]**：
   - 一种广泛用于数据库和文件系统的平衡多叉搜索树，具有多节点和更高的平衡性。

# 使用

平衡二叉搜索树在各种应用中广泛使用，特别是在需要高效查找、插入和删除操作的数据结构中。

#### 数据库索引

数据库索引通常使用 B 树或 B+ 树来实现，因为这些树能够有效地处理大规模数据并保持平衡，提供快速的查找、插入和删除操作。

#### 内存管理

操作系统的内存管理子系统可能使用平衡二叉搜索树来管理空闲内存块和分配请求，以确保高效的内存分配和回收。

#### 集合和映射

编程语言中的集合（Set）和映射（Map）通常使用平衡二叉搜索树来实现，例如 [[Java]] 的 TreeMap 和 TreeSet，它们使用红黑树来保证操作的对数时间复杂度。

## 示例

以下是一个简单的 AVL 树实现示例，展示插入操作和树的平衡：

#### AVL 树的 Python 实现

```python
class AVLNode:
    def __init__(self, key, left=None, right=None, height=1):
        self.key = key
        self.left = left
        self.right = right
        self.height = height

class AVLTree:
    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def right_rotate(self, y):
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1
        x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1
        return x

    def left_rotate(self, x):
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = max(self.get_height(x.left), self.get_height(x.right)) + 1
        y.height = max(self.get_height(y.left), self.get_height(y.right)) + 1
        return y

    def insert(self, root, key):
        if not root:
            return AVLNode(key)
        elif key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        root.height = max(self.get_height(root.left), self.get_height(root.right)) + 1
        balance = self.get_balance(root)

        if balance > 1 and key < root.left.key:
            return self.right_rotate(root)
        if balance < -1 and key > root.right.key:
            return self.left_rotate(root)
        if balance > 1 and key > root.left.key:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
        if balance < -1 and key < root.right.key:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)

        return root

    def pre_order(self, root):
        if not root:
            return
        print(root.key, end=" ")
        self.pre_order(root.left)
        self.pre_order(root.right)

# 示例用法
avl_tree = AVLTree()
root = None
keys = [10, 20, 30, 40, 50, 25]

for key in keys:
    root = avl_tree.insert(root, key)

# 输出 AVL 树的前序遍历
avl_tree.pre_order(root)
```

# 总结

平衡二叉搜索树（BBST）是一种高度平衡的二叉搜索树，能够在 O(log n) 时间复杂度内完成查找、插入和删除操作。常见的平衡二叉搜索树包括 AVL 树、红黑树、Splay 树和 B 树。平衡二叉搜索树广泛应用于数据库索引、内存管理和[[编程语言]]的集合和映射等场景。理解和使用平衡二叉搜索树可以显著提高系统的性能和效率。

