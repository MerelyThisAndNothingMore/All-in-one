---
tags: 
alias:
- LinkedList
---

# 定义

链表（Linked List）是一种线性[[数据结构]]，由一系列节点（Node）组成，每个节点包含数据和指向下一个节点的[[指针]]（引用）。链表中的节点通过指针链接在一起，形成一个链式结构。

## 特点

1. **动态大小**：链表的大小可以动态调整，不需要在创建时指定大小。
2. **节点结构**：每个节点包含数据部分和指向下一个节点的指针部分。
3. **插入和删除**：在链表中插入和删除元素不需要移动其他元素，只需修改指针。
4. **顺序访问**：链表只能顺序访问节点，不支持随机访问。

## 相似概念辨析

### 链表 vs 数组

1. **[[内存]]分配**：
   - **链表**：动态分配内存，节点不必连续存储。
   - **数组**：静态分配内存，元素在内存中连续存储。

2. **访问方式**：
   - **链表**：只能顺序访问，[[时间复杂度]]为 O(n)。
   - **数组**：支持随机访问，时间复杂度为 O(1)。

3. **插入和删除**：
   - **链表**：插入和删除操作时间复杂度为 O(1)。
   - **数组**：插入和删除操作时间复杂度为 O(n)。

### 链表 vs [[Stack|栈]]和[[Queue|队列]]

1. **结构**：
   - **链表**：线性数据结构，每个节点包含数据和指针。
   - **栈**：先进后出（LIFO）的线性数据结构。
   - **队列**：先进先出（FIFO）的线性数据结构。

2. **应用**：
   - **链表**：适用于动态数据集的管理和需要频繁插入和删除操作的场景。
   - **栈**：适用于[[递归]]、撤销操作等场景。
   - **队列**：适用于任务调度、数据缓冲等场景。

## 类型

链表有多种类型，根据节点的指针数量和方向不同，常见的链表类型有：

1. **单向链表（Singly Linked List）**：每个节点只包含一个指向下一个节点的指针。
2. **双向链表（Doubly Linked List）**：每个节点包含两个指针，分别指向前一个节点和后一个节点。
3. **循环链表（Circular Linked List）**：链表的最后一个节点指向第一个节点，形成一个环。

### 示例：单向链表

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node

    def print_list(self):
        current_node = self.head
        while current_node:
            print(current_node.data, end=" -> ")
            current_node = current_node.next
        print("None")

# 示例使用
linked_list = SinglyLinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
linked_list.print_list()  # 输出: 1 -> 2 -> 3 -> None
```

### 示例：双向链表

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            return
        last_node = self.head
        while last_node.next:
            last_node = last_node.next
        last_node.next = new_node
        new_node.prev = last_node

    def print_list(self):
        current_node = self.head
        while current_node:
            print(current_node.data, end=" <-> ")
            current_node = current_node.next
        print("None")

# 示例使用
linked_list = DoublyLinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
linked_list.print_list()  # 输出: 1 <-> 2 <-> 3 <-> None
```

## 使用

1. **实现数据结构**：链表用于实现其他复杂数据结构，如栈、队列、[[哈希表]]等。
2. **动态内存管理**：链表适用于需要频繁插入和删除操作的数据集管理。
3. **图的邻接表**：链表用于[[图]]的邻接表表示法，存储图的顶点和边的信息。
4. **处理大数据集**：链表在处理大数据集时，由于其动态内存分配的特性，能够更有效地管理内存。

### 示例：链表实现队列

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None

    def is_empty(self):
        return self.front is None

    def enqueue(self, data):
        new_node = Node(data)
        if self.rear:
            self.rear.next = new_node
        self.rear = new_node
        if not self.front:
            self.front = self.rear

    def dequeue(self):
        if self.is_empty():
            return None
        dequeued_node = self.front
        self.front = self.front.next
        if not self.front:
            self.rear = None
        return dequeued_node.data

    def print_queue(self):
        current_node = self.front
        while current_node:
            print(current_node.data, end=" -> ")
            current_node = current_node.next
        print("None")

# 示例使用
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
queue.print_queue()  # 输出: 1 -> 2 -> 3 -> None
print(queue.dequeue())  # 输出: 1
queue.print_queue()  # 输出: 2 -> 3 -> None
```

## Q & A

**Q1: 为什么选择链表而不是数组？**

A1: 链表在需要频繁插入和删除操作时表现更好，因为这些操作在链表中的时间复杂度为 O(1)，而在数组中为 O(n)。链表还具有动态大小，可以根据需要调整内存分配，而数组大小固定，可能会浪费或不足。

**Q2: 链表有哪些常见类型？**

A2: 常见的链表类型包括单向链表、双向链表和循环链表。单向链表每个节点只有一个指向下一个节点的指针；双向链表每个节点有两个指针，分别指向前一个和后一个节点；循环链表的最后一个节点指向第一个节点，形成一个环。

**Q3: 如何在链表中查找一个元素？**

A3: 在链表中查找元素需要从头节点开始，逐个[[遍历]]节点，直到找到目标元素或遍历到链表的末尾。查找操作的时间复杂度为 O(n)。

**Q4: 双向链表有哪些优势？**

A4: 双向链表的优势包括：可以从任意节点向前或向后遍历，更容易实现删除操作（因为可以直接访问前一个节点），适用于需要双向遍历的场景。

**Q5: 如何处理链表中的循环引用问题？**

A5: 链表中的循环引用问题可以通过快慢指针法（Floyd's Cycle-Finding Algorithm）检测。快指针每次移动两步，慢指针每次移动一步。如果链表中存在循环，快慢指针最终会相遇。



