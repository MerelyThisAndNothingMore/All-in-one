---
tags:
  - java
  - jvm
aliases:
  - Generational Collection
---

# 定义

**分代收集（Generational Garbage Collection）** 是一种[[垃圾收集]][[算法]]，基于[[对象]]的生命周期特点，将[[Java 堆]][[内存]]分成几代（通常为新生代和老年代），并分别对不同代进行垃圾收集。分代收集的核心思想是，大多数对象在其生命周期开始时很快就会变得不可达，而少数对象会存活较长时间。因此，通过将堆内存分代，并对每代应用不同的垃圾收集策略，可以提高垃圾收集的效率和性能。

## 特点

1. **代分类**：
   - 堆内存通常被分为新生代、老年代和永久代（或元数据区）。新生代主要存放新创建的对象，老年代存放长时间存活的对象，永久代存放[[类]]元数据和静态变量。
   
2. **不同的收集策略**：
   - 对新生代进行频繁、快速的垃圾收集（如复制算法），对老年代进行较少但更彻底的收集（如标记-清除或标记-压缩算法）。
   
3. **提升（Promotion）**：
   - 当对象在新生代经历一定次数的垃圾收集后仍然存活，它们会被提升到老年代。
   
4. **效率提升**：
   - 通过区分对象的存活时间和频繁收集新生代的短命对象，减少了对老年代的收集频率，提高了整体垃圾收集的效率。

## 相似概念辨析

1. **分代收集 vs 标记-清除**：
   - 标记-清除（[[标记-清除算法|Mark-Sweep]]）算法是对整个堆内存进行垃圾收集，而分代收集是基于对象的生命周期特征进行分代，并对不同代采用不同的收集策略。
   
2. **分代收集 vs 引用计数**：
   - 引用计数（Reference Counting）通过维护每个对象的引用计数来进行垃圾收集，而分代收集则通过分代和不同的收集策略来优化垃圾收集过程。

3. **分代收集 vs 增量收集**：
   - 增量收集（Incremental Garbage Collection）是将垃圾收集过程分成小块，逐步完成，以减少垃圾收集暂停时间。分代收集则通过分代和不同的收集策略提高效率和性能。

# 原理

分代收集基于两个关键观察：

1. **多数对象是短命的**：
   - 大部分对象在创建后不久就会变得不可达，因此频繁收集新生代中的对象可以快速回收大量内存。

1. **存活时间长的对象更有可能继续存活**：
   - 对于存活时间较长的对象，使用较少频率的收集策略进行处理可以减少垃圾收集的开销。

根据这些观察，分代收集将堆内存分为新生代和老年代：

1. **新生代**：
   - 包括Eden区和两个Survivor区（通常记为From和To）。新创建的对象首先分配在Eden区，当Eden区满时，触发一次新生代垃圾收集（Minor GC），存活的对象移到Survivor区。

2. **老年代**：
   - 包含那些从新生代提升（Promoted）过来的长期存活对象。老年代的垃圾收集（Major GC或Full GC）频率较低，但通常涉及更全面的垃圾回收。

#### 使用

分代收集广泛应用于现代垃圾收集器，特别是在Java虚拟机（JVM）中。以下是一些常见的垃圾收集器及其使用场景：

1. **Java HotSpot VM**：
   - 包含多种分代收集器，如串行收集器（Serial Collector）、并行收集器（Parallel Collector）、并行压缩收集器（Parallel Compacting Collector）和垃圾优先收集器（G1 Garbage Collector）。

2. **其他JVM实现**：
   - 如OpenJ9、GraalVM等，也实现了分代收集策略，以优化内存管理和性能。

#### 示例

以下是Java中分代收集的示例，演示新生代和老年代的垃圾收集：

```java
public class GCDemo {
    public static void main(String[] args) {
        for (int i = 0; i < 100000; i++) {
            createObject();
        }
    }

    private static void createObject() {
        byte[] array = new byte[1024]; // 创建对象在Eden区
    }
}
```

#### Q & A

1. **分代收集的优点是什么？**
   - 提高垃圾收集的效率和性能，通过频繁收集新生代中的短命对象，减少老年代的垃圾收集频率。

2. **什么是新生代和老年代？**
   - 新生代存放新创建的短命对象，老年代存放长期存活的对象。新生代的垃圾收集频率高而老年代频率低。

3. **如何提升对象到老年代？**
   - 当对象在新生代经历多次垃圾收集后仍然存活，它们会被提升到老年代。

4. **有哪些常见的分代收集器？**
   - 如Java HotSpot VM中的Serial Collector、Parallel Collector、Parallel Compacting Collector和G1 Garbage Collector。

通过理解分代收集的定义、特点、原理和实际应用，可以更好地优化程序的内存管理，提高程序的性能和稳定性。



分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上:

1. 弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。 
2. 强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的[[垃圾收集器]]的一致的设计原则: 收集器应该将[[Java 堆]]划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。


## 算法思路
-   根据 **对象存活周期的不同** 将 `Java`堆内存 分为：新生代 & 老年代 。分配比例如下：
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1hZWJhODAwYzljZDMxYjk5LnBuZw?x-oss-process=image/format,png)
- 根据 两块区域特点 选择 对应的垃圾收集算法
![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01ZmRjNmI3YjM0NjcyZTVkLnBuZw?x-oss-process=image/format,png)
## 具体存储过程
新建的对象 一般会被优先分配到新生代的Eden区、From Survivor区
>大对象（如很长的字符串以及数组）会直接分配到老年代，这是为了避免在 Eden 区 和 Survivor区之间发生大量的内存复制（因为新生代会采用复制算法进行垃圾收集）

这些对象经过第一次 Minor GC后，若仍然存活，将会被移到To Survivor区
一次清理掉Eden、From Survivor区域

在 To Survivor 区每经过一轮 Minor GC ，该对象的年龄就+1
当对象年龄达到一定时(阈值默认=15)，就会被移动到老年代。
- 即新生代的对象在存活一定时间后，会被移动存储到老年代区域。
- 还有一种新生代对象被移懂到老年代区域的情况是：动态对象年龄判定。即如果在Survivor区中 所有相同年龄对象的大小总和大于Survivor区内存大小一半时，所有大于或等于该年龄的对象都会直接进入老年代。
### 特别注意
From Survivor 和 To Survivor之间会经常互换角色。

每次发生GC时，把Eden区和 From Survivor区中 存活且没超过年龄阈值的对象 复制到To Survivor区中（此时To Survivor变成了From Survivor），然后From Survivor清空（此时From Survivor变成了To Survivor）

## 总结
### 优点
效率高、空间利用率高

根据不同区域特点 选择 不同的垃圾收集算法

### 应用场景
现在主流的虚拟机基本都采用 分代收集算法 ，即根据不同区域特点选择不同垃圾收集算法。

新生代 区域：采用 复制算法
老年代 区域：采用 标记-清除 算法、标记 - 整理 算法


