---
tags: 
alias:
---

帧缓存实际上就是一块[[内存]]。在 [[Android]] 系统中分配与回收帧缓存，使用的是一个叫 ION 的内核模块，App 使用 ioctl 系统调用后，会在内核内存中分配一块符合要求的内存，用户态会拿到一个 fd（有的地方也称之为 handle），然后接着调用 mmap ，就能把内核[[内存映射]]到用户态内存中，接着返回对应的用户态内存地址给 App。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/JbNtVM0Jpq0uZt4qOD7uNyhLQR65X3EpUl0knk1gOwMP6HyUJl8SI2TibURGSWEwq0HttXmiavzVfwHxptQ3JJzg/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在 Android 中，ION 被封装在了 Gralloc HAL 中，这是一个 [[AIDL]] HAL，Native App 可以直接访问这个 HAL。Gralloc Hal 进一步去访问 ION 模块分配回收内存，ION 分配的是内核内存.

Native App 调用 Gralloc Hal 分配好内存以后，可以调用 mmap 把内核内存映射到用户态，然后 App 可以来填充这块内存了，这个填充的过程就是常说的渲染，渲染通常通过一些图形库来完成，比如 skia,opengles 等，硬件上可以是使用 cpu 或者 gpu，通常 gpu 效率更好。

填充完了，就可以把这块 buffer 的 fd 发送给 SurfaceFinger。因为同一时间有多个 app 和 sf 交互，SurfaceFlinger 大概率会收到多个 buffer。

比如在 Launcher 中，最上面的状态栏和导航栏是一个图层对应一个 buffer，后面的壁纸是一个图层对应一个 buffer，各种 App 图标是一个图层对应一个 buffer。

SurfaceFlinger 会把这些 buffer 交给 HWComposer HAL， HWComposer HAL 会把这些 buffer 合并为一个 buffer，合并一般有两种类型：

- 一种是通过特定的硬件来合并，比如，高通的 soc 中，用于专门合并 buffer 的模块叫 mdp，一般效率很高。
    
- 一种是通过 opengl 等图形库来合并，图形库本身会去使用 cpu 或者 gpu 来合并，使用 cpu 还是 gpu 一般取决于相应的配置
    

接着显示电路就会把合并好的 buffer 转换为电信号，传递给显示设备显示。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/JbNtVM0Jpq0uZt4qOD7uNyhLQR65X3EpGdfEQ0iaB9mkj8dysfcHhe7Osgp1ySaZibw3UzpdoCJtkeZzkKeaG2gQ/640?wx_fmt=png&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

