---
tags: 
alias:
---

### 多态 (Polymorphism)

#### 定义

多态是[[面向对象编程]] (OOP) 的核心概念之一，指的是同一[[接口]]、函数或[[方法]]可以在不同的上下文中表现出不同的行为。多态性允许对象以不同的形式进行操作，简化了代码的扩展和维护。主要类型包括编译时多态和运行时多态。

#### 特点

1. **接口一致性**：
   - 多态性允许不同的对象通过相同的接口进行操作，从而实现接口一致性。

2. **代码重用**：
   - 通过多态性，可以编写更通用和可重用的代码，减少重复代码。

3. **动态绑定**：
   - 运行时多态性通过动态绑定机制实现，允许在运行时确定调用哪一个具体的函数实现。

4. **灵活性和可扩展性**：
   - 多态性使得代码更加灵活和可扩展，便于添加新功能而不影响现有代码。

#### 相似概念辨析

1. **多态 vs 继承**：
   - 继承是实现多态的一种手段，通过继承可以使子类重写父类的方法，而多态是通过父类引用指向子类对象实现的行为多样性。

2. **多态 vs 重载**：
   - 重载是编译时多态的一种形式，通过同一函数名但不同参数列表实现多态。而多态通常指运行时多态，通过继承和接口实现的多态性。

3. **多态 vs 封装**：
   - 封装是将对象的状态和行为封装在一个类中，隐藏其内部实现细节。多态通过封装的接口进行操作，但两者侧重点不同。

#### 原理

多态的实现原理主要包括两种方式：编译时多态（静态多态）和运行时多态（动态多态）。

1. **编译时多态（静态多态）**：
   - 通过函数重载和运算符重载实现。在编译阶段，编译器决定调用哪一个重载的函数版本。
   - 示例：
     ```cpp
     class Print {
     public:
         void display(int i) {
             std::cout << "Integer: " << i << std::endl;
         }

         void display(double f) {
             std::cout << "Double: " << f << std::endl;
         }
     };

     Print obj;
     obj.display(5);     // 调用 display(int i)
     obj.display(3.14);  // 调用 display(double f)
     ```

2. **运行时多态（动态多态）**：
   - 通过继承和虚函数实现。在运行时，通过基类指针或引用调用派生类的重写方法。
   - 示例：
     ```cpp
     class Base {
     public:
         virtual void show() {
             std::cout << "Base class" << std::endl;
         }
     };

     class Derived : public Base {
     public:
         void show() override {
             std::cout << "Derived class" << std::endl;
         }
     };

     Base* b = new Derived();
     b->show();  // 调用 Derived 类的 show() 方法
     ```

#### 使用

多态在面向对象编程中有广泛的应用，特别是在设计灵活且可扩展的系统时。以下是一些常见的使用场景：

1. **接口和实现分离**：
   - 使用多态性，可以定义统一的接口，不同的实现类可以有不同的行为。
   - 示例：
     ```cpp
     class Shape {
     public:
         virtual void draw() = 0;  // 纯虚函数
     };

     class Circle : public Shape {
     public:
         void draw() override {
             std::cout << "Drawing Circle" << std::endl;
         }
     };

     class Square : public Shape {
     public:
         void draw() override {
             std::cout << "Drawing Square" << std::endl;
         }
     };

     Shape* shape1 = new Circle();
     Shape* shape2 = new Square();
     shape1->draw();  // 输出 "Drawing Circle"
     shape2->draw();  // 输出 "Drawing Square"
     ```

2. **回调函数和事件处理**：
   - 通过多态性实现回调函数，允许不同的事件处理器处理不同的事件。

3. **设计模式**：
   - 多态是许多设计模式（如策略模式、状态模式、观察者模式等）的基础，允许对象在运行时改变行为。

#### Q & A

1. **什么是多态性？**
   - 多态性是指同一接口或方法在不同上下文中可以表现出不同的行为。通过继承和接口，可以实现对象的动态行为变化。

2. **多态性有哪些类型？**
   - 多态性包括编译时多态（如函数重载、运算符重载）和运行时多态（如虚函数、接口实现）。

3. **多态性的优点是什么？**
   - 多态性使得代码更加灵活和可扩展，简化了代码的重用和维护，提高了系统的可扩展性。

4. **如何实现运行时多态性？**
   - 通过继承基类和重写基类的[[虚函数]]，可以实现运行时多态性。在运行时，通过基类[[指针]]或引用调用派生类的具体实现。

多态性是面向对象编程的重要特性之一，通过合理使用多态性，可以编写出更加灵活、可维护和可扩展的代码。