---
tags: 
aliases:
  - Annotation Processor
---

## 定义

注解处理器（Annotation Processor）是编程语言（如 Java 和 Kotlin）中用于在编译时处理注解的工具。它允许开发者在编译过程中扫描代码中的注解，根据注解生成或修改代码，进行验证和检查等操作。注解处理器通常用于自动生成代码、简化编程任务和提高代码的可维护性。

## 特点

1. **编译时处理**：注解处理器在编译期间运行，对源代码中的注解进行处理。
2. **代码生成**：根据注解生成额外的代码，如工厂类、代理类等。
3. **代码检查**：对代码进行验证和检查，确保符合预期的规范和规则。
4. **灵活性**：可以处理各种自定义注解，提供丰富的扩展能力。
5. **工具支持**：与编译器和构建工具（如 Gradle、Maven）集成，自动执行。

## 结构

注解处理器通常包括以下几个部分：

1. **注解**：定义自定义注解，用于标记需要处理的代码元素。
2. **处理器类**：实现 `javax.annotation.processing.Processor` 接口，定义处理注解的逻辑。
3. **配置文件**：在 `META-INF/services` 目录下创建配置文件，声明注解处理器的实现类。

### 示例：Java 实现注解处理器

### 定义自定义注解

```java
package com.example.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface MyAnnotation {
    String value();
}
```

### 实现注解处理器

```java
package com.example.processor;

import com.example.annotations.MyAnnotation;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.Element;
import javax.tools.Diagnostic;
import java.util.Set;

@SupportedAnnotationTypes("com.example.annotations.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class MyAnnotationProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(MyAnnotation.class)) {
            MyAnnotation annotation = element.getAnnotation(MyAnnotation.class);
            String message = "Processing: " + element.getSimpleName() + " with value: " + annotation.value();
            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message);
        }
        return true;
    }
}
```

### 配置文件

在 `META-INF/services` 目录下创建文件 `javax.annotation.processing.Processor`，并添加注解处理器的实现类的全限定名：

```
com.example.processor.MyAnnotationProcessor
```

### 使用注解

```java
package com.example;

import com.example.annotations.MyAnnotation;

@MyAnnotation("Hello, World!")
public class MyClass {
    // 类内容
}
```

在编译时，注解处理器将处理 `@MyAnnotation` 注解，并在控制台输出处理信息。

## 使用场景

注解处理器在编译时进行注解处理，主要用于以下场景：

1. **代码生成**：自动生成代码，减少样板代码，提高开发效率。例如，生成工厂类、代理类、数据访问层代码等。
2. **代码检查**：在编译时进行代码验证和检查，确保代码符合预期的规范和规则。例如，验证依赖注入配置、接口实现等。
3. **代码文档生成**：根据注解生成代码文档，提供开发文档和 API 说明。
4. **框架和库开发**：开发自定义框架和库，提供自动化配置和代码生成能力。

### 示例：代码生成

以下是一个生成工厂类的示例：

#### 定义工厂注解

```java
package com.example.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface Factory {
    String value();
}
```

#### 实现工厂注解处理器

```java
package com.example.processor;

import com.example.annotations.Factory;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.util.Set;

@SupportedAnnotationTypes("com.example.annotations.Factory")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class FactoryProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(Factory.class)) {
            Factory factory = element.getAnnotation(Factory.class);
            String className = element.getSimpleName() + "Factory";
            try {
                JavaFileObject file = processingEnv.getFiler().createSourceFile("com.example.generated." + className);
                try (Writer writer = file.openWriter()) {
                    writer.write("package com.example.generated;\n");
                    writer.write("public class " + className + " {\n");
                    writer.write("    public static " + element.getSimpleName() + " create() {\n");
                    writer.write("        return new " + element.getSimpleName() + "();\n");
                    writer.write("    }\n");
                    writer.write("}\n");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return true;
    }
}
```

#### 配置文件

在 `META-INF/services` 目录下创建文件 `javax.annotation.processing.Processor`，并添加注解处理器的实现类的全限定名：

```
com.example.processor.FactoryProcessor
```

#### 使用注解

```java
package com.example;

import com.example.annotations.Factory;

@Factory("MyClass")
public class MyClass {
    // 类内容
}
```

在编译时，注解处理器将生成 `MyClassFactory` 类：

```java
package com.example.generated;

public class MyClassFactory {
    public static MyClass create() {
        return new MyClass();
    }
}
```

## Q & A

**Q1: 注解处理器在什么时候运行？**

A1: 注解处理器在编译期间运行，在编译器处理源代码时扫描注解，并根据注解生成代码、进行验证或执行其他处理。

**Q2: 如何调试注解处理器？**

A2: 可以通过在注解处理器中添加日志输出（如 `processingEnv.getMessager().printMessage`）进行调试。还可以使用调试工具设置断点，调试编译器进程。

**Q3: 注解处理器可以生成哪些类型的文件？**

A3: 注解处理器可以生成 Java 源代码文件、资源文件（如 XML、JSON）等。通过 `processingEnv.getFiler` 获取 `Filer` 对象，然后使用 `createSourceFile` 或 `createResource` 方法生成文件。

**Q4: 注解处理器是否可以处理所有类型的注解？**

A4: 是的，注解处理器可以处理所有类型的注解。通过在注解处理器类上使用 `@SupportedAnnotationTypes` 注解，指定要处理的注解类型。

**Q5: 注解处理器与 KSP 有什么区别？**

A5: 注解处理器是 Java 的标准工具，而 KSP（Kotlin Symbol Processing）是专为 Kotlin 设计的符号处理工具。KSP 提供了更高效和灵活的 Kotlin 编译时处理支持，直接处理 Kotlin 源代码符号，而不需要将 Kotlin 代码转换为 Java 抽象语法树（AST）。