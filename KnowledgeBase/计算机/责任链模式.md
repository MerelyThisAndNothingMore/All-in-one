---
tags: 
aliases:
  - Chain of Responsibility Pattern
---

# 定义

责任链模式是一种行为[[设计模式]]，它通过将请求沿着一条链传递，直到有对象处理请求为止。责任链模式允许多个对象有机会处理请求，从而解耦请求的发送者和接收者。

## 特点

1. **请求解耦**：将请求的发送者与接收者解耦，发送者不需要知道哪个对象处理请求。
2. **动态组合**：可以通过动态组合对象来灵活地调整责任链的结构。
3. **提高灵活性**：责任链可以动态添加或删除处理器，灵活应对变化。
4. **降低耦合度**：责任链中各处理器彼此独立，降低了对象之间的耦合度。

## 结构

责任链模式通常由以下几个部分组成：

1. **Handler（处理者）**：定义一个处理请求的接口。
2. **ConcreteHandler（具体处理者）**：实现处理请求的逻辑，并维护对下一个处理者的引用。
3. **Client（客户端）**：创建请求，并将其发送到责任链的第一个处理者。

### 结构图

```plaintext
Client -> Handler1 -> Handler2 -> Handler3 -> ... -> HandlerN
```

## 工作流程

1. **请求发送**：客户端将请求发送到责任链的第一个处理者。
2. **处理请求**：处理者收到请求后，检查自己是否能够处理。如果可以处理，则处理请求；否则，将请求传递给下一个处理者。
3. **传递请求**：请求沿着责任链传递，直到某个处理者处理请求或责任链的末端。

## 示例代码

以下是一个使用责任链模式的简单示例，展示了一个审批流程：

```java
// 处理者接口
abstract class Approver {
    protected Approver nextApprover;

    public void setNextApprover(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    public abstract void processRequest(PurchaseRequest request);
}

// 具体处理者：主任
class Director extends Approver {
    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < 5000) {
            System.out.println("Director approved request for amount: $" + request.getAmount());
        } else if (nextApprover != null) {
            nextApprover.processRequest(request);
        }
    }
}

// 具体处理者：副总
class VicePresident extends Approver {
    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < 10000) {
            System.out.println("Vice President approved request for amount: $" + request.getAmount());
        } else if (nextApprover != null) {
            nextApprover.processRequest(request);
        }
    }
}

// 具体处理者：总裁
class President extends Approver {
    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getAmount() < 20000) {
            System.out.println("President approved request for amount: $" + request.getAmount());
        } else {
            System.out.println("Request for amount: $" + request.getAmount() + " requires a board meeting!");
        }
    }
}

// 采购请求
class PurchaseRequest {
    private double amount;

    public PurchaseRequest(double amount) {
        this.amount = amount;
    }

    public double getAmount() {
        return amount;
    }
}

// 客户端
public class ChainOfResponsibilityDemo {
    public static void main(String[] args) {
        // 创建处理者
        Approver director = new Director();
        Approver vp = new VicePresident();
        Approver president = new President();

        // 设置责任链
        director.setNextApprover(vp);
        vp.setNextApprover(president);

        // 创建请求并传递给责任链
        PurchaseRequest request1 = new PurchaseRequest(3000);
        PurchaseRequest request2 = new PurchaseRequest(7000);
        PurchaseRequest request3 = new PurchaseRequest(15000);
        PurchaseRequest request4 = new PurchaseRequest(25000);

        director.processRequest(request1);
        director.processRequest(request2);
        director.processRequest(request3);
        director.processRequest(request4);
    }
}
```

### 输出结果

```plaintext
Director approved request for amount: $3000.0
Vice President approved request for amount: $7000.0
President approved request for amount: $15000.0
Request for amount: $25000.0 requires a board meeting!
```

### 示例解释

在这个示例中，我们实现了一个简单的审批流程：

- **Director（主任）**负责处理小于 $5,000 的请求。
- **Vice President（副总）**负责处理小于 $10,000 的请求。
- **President（总裁）**负责处理小于 $20,000 的请求。
- 如果请求金额超过 $20,000，则需要召开董事会会议。

每个具体处理者都有一个指向下一个处理者的引用，形成一个责任链。请求从链的第一个处理者开始传递，直到找到能够处理请求的处理者或责任链结束。

## 使用场景

责任链模式适用于以下场景：

1. **多对象可处理同一请求**：多个对象可能处理请求，但不需要明确哪个对象处理。
2. **请求动态处理**：请求的处理需要在运行时进行动态处理。
3. **减少耦合**：需要将请求的发送者与接收者解耦，以提高灵活性和可维护性。

### 常见应用

- **审批流程**：如采购审批、请假审批等。
- **日志处理**：不同级别的日志由不同的处理器处理。
- **请求处理器**：如 HTTP 请求过滤器链。

## 优缺点

### 优点

1. **降低耦合度**：请求发送者和接收者解耦，提高系统的灵活性和可扩展性。
2. **动态灵活性**：可以通过添加或删除处理者动态调整责任链。
3. **增强扩展性**：通过继承和实现新的处理者，可以方便地扩展责任链。

### 缺点

1. **性能问题**：责任链过长可能导致请求处理效率低。
2. **不易调试**：请求沿链传递，可能导致难以确定请求处理的最终位置。
3. **可能不处理请求**：如果责任链中没有处理者能处理请求，可能导致请求未被处理。

## Q & A

**Q1: 什么是责任链模式？**

A1: 责任链模式是一种行为设计模式，通过将请求沿着一条链传递，直到有对象处理请求为止，解耦请求的发送者和接收者。

**Q2: 责任链模式有哪些优点？**

A2: 责任链模式降低了请求发送者与接收者的耦合，提高了系统的灵活性和可扩展性，支持动态调整责任链。

**Q3: 责任链模式适用于哪些场景？**

A3: 责任链模式适用于多个对象可能处理同一请求、请求需要动态处理、需要解耦请求发送者与接收者的场景。

**Q4: 责任链模式的缺点是什么？**

A4: 责任链模式可能导致性能问题、调试困难和请求未被处理的问题。

**Q5: 如何实现责任链模式？**

A5: 责任链模式通过定义处理者接口，具体实现处理者并维护对下一个处理者的引用，形成责任链来处理请求。