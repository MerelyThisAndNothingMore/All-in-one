---
tags: 
aliases:
  - Iterator Pattern
---

# 定义

迭代器模式（Iterator Pattern）是一种行为[[设计模式]]，它提供一种[[方法]]顺序访问一个聚合[[对象]]中的各个元素，而不需要暴露该对象的内部表示。迭代器模式将[[集合]]对象的[[遍历]]操作从集合对象中分离出来，使得不同的遍历方式可以独立于集合对象而变化。

## 特点

1. **统一接口**：提供一个统一的[[接口]]，用于遍历不同类型的集合。
2. **封装遍历细节**：迭代器[[封装]]了遍历集合的细节，用户无需关心集合的内部结构。
3. **支持多种遍历方式**：可以通过不同的迭代器实现支持多种遍历方式（如正序、逆序、随机等）。
4. **分离集合与遍历**：集合对象和遍历操作分离，提高代码的可扩展性和可维护性。

## 结构

迭代器模式主要包含以下几个部分：

1. **迭代器接口（Iterator）**：定义访问和遍历元素的接口。
2. **具体迭代器（Concrete Iterator）**：实现迭代器接口，负责遍历集合元素。
3. **聚合接口（Aggregate）**：定义创建迭代器的接口。
4. **具体聚合（Concrete Aggregate）**：实现聚合接口，创建具体迭代器对象。

### 类图

```plaintext
+--------------+      +-----------------------+
|   Iterator   |<-----|     ConcreteIterator  |
+--------------+      +-----------------------+
| +hasNext()   |      | +hasNext()            |
| +next()      |      | +next()               |
+--------------+      +-----------------------+
        ^
        |
+---------------+      +-----------------------+
|   Aggregate   |<-----|   ConcreteAggregate   |
+---------------+      +-----------------------+
| +createIterator()|   | +createIterator()     |
+---------------+      +-----------------------+
```

## 示例：[[Java]] 实现迭代器模式

### 迭代器接口

```java
public interface Iterator<T> {
    boolean hasNext();
    T next();
}
```

### 具体迭代器

```java
public class ConcreteIterator<T> implements Iterator<T> {
    private List<T> list;
    private int position;

    public ConcreteIterator(List<T> list) {
        this.list = list;
        this.position = 0;
    }

    @Override
    public boolean hasNext() {
        return position < list.size();
    }

    @Override
    public T next() {
        if (this.hasNext()) {
            return list.get(position++);
        }
        return null;
    }
}
```

### 聚合接口

```java
public interface Aggregate<T> {
    Iterator<T> createIterator();
}
```

### 具体聚合

```java
public class ConcreteAggregate<T> implements Aggregate<T> {
    private List<T> list = new ArrayList<>();

    public void add(T element) {
        list.add(element);
    }

    @Override
    public Iterator<T> createIterator() {
        return new ConcreteIterator<>(list);
    }
}
```

### 使用迭代器模式

```java
public class Main {
    public static void main(String[] args) {
        ConcreteAggregate<String> aggregate = new ConcreteAggregate<>();
        aggregate.add("Element 1");
        aggregate.add("Element 2");
        aggregate.add("Element 3");

        Iterator<String> iterator = aggregate.createIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

在这个示例中，`ConcreteAggregate` 类实现了 `Aggregate` 接口，并提供了一个创建 `ConcreteIterator` 的方法。`ConcreteIterator` 类实现了 `Iterator` 接口，负责遍历 `ConcreteAggregate` 的元素。

## 使用场景

迭代器模式适用于以下场景：

1. **访问一个聚合对象的内容而无需暴露其内部表示**：当你需要遍历一个集合对象时，不需要了解其内部实现。
2. **需要支持多种遍历方式**：通过不同的迭代器实现，可以支持多种遍历方式。
3. **提供一个统一的接口遍历不同类型的聚合对象**：无论聚合对象的具体类型如何，都可以通过迭代器进行遍历。

# Q & A

**Q1: 迭代器模式的主要优点是什么？**

A1: 迭代器模式的主要优点包括：
- 提供一个统一的接口遍历不同类型的集合。
- 封装集合的遍历细节，提高代码的可扩展性和可维护性。
- 支持多种遍历方式，便于扩展。

**Q2: 迭代器模式与集合框架有何关系？**

A2: 迭代器模式与集合框架关系密切，集合框架通常通过迭代器模式提供对集合元素的遍历功能。例如，Java 集合框架中的 `Iterator` 接口和 `Iterable` 接口都是迭代器模式的具体实现。

**Q3: 迭代器模式如何支持多种遍历方式？**

A3: 通过创建不同的迭代器实现，可以支持多种遍历方式。例如，可以实现正序遍历、逆序遍历、随机遍历等。

**Q4: 迭代器模式是否会影响集合对象的封装性？**

A4: 不会。迭代器模式通过提供一个统一的遍历接口，避免了直接暴露集合对象的内部结构，从而保持了集合对象的封装性。

**Q5: 迭代器模式在实际开发中有哪些应用？**

A5: 迭代器模式在实际开发中的应用非常广泛。例如：
- 遍历列表、集合、映射等数据结构。
- 文件系统中的[[Files|文件]]和目录遍历。
- 数据库结果集的遍历。