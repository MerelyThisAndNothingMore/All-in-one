---
tags: 
alias:
---
https://www.jianshu.com/p/37370c1d17fc

https://mp.weixin.qq.com/s/b6-leHKQZkuxkjll-1109A
# [[Input触控事件处理]]

# 应用程序创建和启动
![](https://gd-hbimg.huaban.com/6ed5ce04b6586ffa92d944d83b293535a67b87aee6fc-Cl4LRw)
应用程序的启动过程其实就是根[[Activity]]的启动过程。
## Launcher进程请求[[AMS]]
桌面进程收到 input 触控事件并处理后 [[Binder]] 调用框架 AMS 的的 startActivity 接口启动应用

点击图标发生在 Launcher 应用的进程,实际上执行的是 Launcher 的 onClick 方法，在 onClick 里面会执行到 Activity 的 startActivity 方法。 startActivity 会调用 mInstrumentation.execStartActivity(); execStartActivity 通过 ActivityManager 的 getService 方法来得到 AMS 的代理对象

( Launcher 进程作为客户端与服务端 AMS 不在同一个进程, ActivityManager.getService 返回的是 IActivityManager.Stub 的代理对象,此 时如果要实现客户端与服务端进程间的通信， 需要 AMS 继承 IActivityManager.Stub 类并实现相应的方法,这样 Launcher进程作为客户端就拥有了服务端AMS的代理对象，然后就可以调用AMS的方法来实现具体功能了)

[[AMS|AMS]] 在[[system_server进程|system_server进程]]中。
## [[AMS|AMS]] pause 桌面应用
AMS 中的 [[Activity]] 栈管理的逻辑，检查发现当前处于前台 Resume 状态的 Activity 是桌面应用，所以第一步需要通知桌面应用的 Activity 进入 Paused 状态


## [[AMS]]发送创建应用进程请求
AMS 这边收到应用的 activityPaused 调用后，继续执行启动应用的逻辑，判断需要启动的应用 Activity 所在的进程不存在，所以接下来需要先 startProcessAsync 创建应用进程

Android 系统中一般应用进程的创建都是统一由 [[zygote进程]] fork 创建的，AMS 在需要创建应用进程时，会通过 [[Socket]] 连接并通知到到 zygote 进程在开机阶段就创建好的 socket 服务端，然后由 zygote 进程 fork 创建出应用进程。

Zygote进程接受请求并fork[[app进程]]
AMS 通过 socket 通信告知 Zygote 进程 fork 子进程。

main方法中创建ApplicationThread，Looper，Handler 对象，并开启主线程消息循环Looper.loop()。
## 应用进程初始化
1. 应用进程默认的 java 异常处理机制（可以实现监听、拦截应用进程所有的 Java crash 的逻辑）；
    
2. JNI 调用启动进程的 binder 线程池（注意应用进程的 binder 线程池资源是自己创建的并非从 zygote 父进程继承的）；
    
3. 通过反射创建 [[ActivityThread]] 对象并调用其 “main” 入口方法。

进程 ActivityThread#main 函数初始化的主要逻辑是：

1. 创建并启动主线程的 loop 消息循环；
    
2. 通过 binder 调用 AMS 的 attachApplication 接口将自己 attach 注册到 AMS 中。

主线程初始化之后，主线程就有了完整的[[Looper]]、[[Message Queue]]、[[Handler]]。

主线程初始化完成后，主线程就进入阻塞状态，等待 Message，一旦有 Message 发过来，主线程就会被唤醒，处理 Message，处理完成之后，如果没有其他的 Message 需要处理，那么主线程就会进入休眠阻塞状态继续等待。可以说 Android 系统的运行是受消息机制驱动的，而整个消息机制是由上面所说的四个关键角色相互配合实现的（Handler、Looper、MessageQueue、Message）


## 发起attachApplication请求
[[app进程]]通过Binder(IActivityManager)向[[AMS]]([[system_server进程]]中)发起attachApplication请求,

AMS绑定ApplicationThread在 的 main 中,通过 ,将 AMS 绑定 ApplicationThread 对象,这样 AMS 就可以通过这个代理对象 来控制应用进程。

## 发送scheduleLaunchActivity
[[system_server进程|system_server进程]] 在收到请求后，进行一系列准备工作后，再通过 [[Binder]] ([[ApplicationThread|ApplicationThread]])向[[app进程]]发送scheduleLaunchActivity 请求; 

## handleBindApplication
1. 根据框架传入的 ApplicationInfo 信息创建应用 APK 对应的 LoadedApk 对象；
    
2. 创建应用 Application 的 Context 对象；
    
3. 创建类加载器 ClassLoader 对象并触发 Art 虚拟机执行 OpenDexFilesFromOat 动作加载应用 APK 的 Dex 文件；
    
4. 通过 LoadedApk 加载应用 APK 的 Resource 资源；
    
5. 调用 LoadedApk 的 makeApplication 函数，创建应用的 Application 对象；
    
6. 执行应用 Application#onCreate 生命周期函数（APP 应用开发者能控制的第一行代码）;

在创建 Application 的 Context 对象后会立马尝试去加载 APK 的 Resource 资源，而在这之前需要通过 LoadedApk 去创建类加载器 ClassLoader 对象，而这个过程最终就会触发 Art 虚拟机加载应用 APK 的 dex 文件

系统对于应用 APK 文件资源的加载过程其实就是创建应用进程中的 Resources 资源对象的过程，其中真正实现 APK 资源文件的 I/O 解析，最终是借助于 AssetManager 中通过 JNI 调用系统 Native 层的相关 C 函数实现。

## ApplicationThread
App 进程的 binder 线程( ApplicationThread )在收到请求后，通过 handler 向主线程发送 LAUNCH_ACTIVITY 消息;

## [[ActivityThread]]的Handler处理LAUNCHER_ACTIVITY

### create
主线程在收到 Message 后，handleLaunchActivity()，通过反射机制创建目标 Activity ，并回调 Activity.onCreate() 等方法。 

1. 创建 Activity 的 Context；
    
2. 通过反射创建 Activity 对象；
    
3. 执行 Activity 的 attach 动作，其中会创建应用窗口的 PhoneWindow 对象并设置 WindowManage；
    
4. 执行应用 Activity 的 onCreate 生命周期函数，并在 setContentView 中创建窗口的 [[DecorView]] 对象；

### resume 

到此， App 便正式启动，开始进入 Activity 生命周期，执行完 onCreate/onStart/onResume 方法， UI 渲染结束后便可以看到 App 的主界面。

1. 执行应用 Activity 的 onResume 生命周期函数；
    
2. 执行 WindowManager 的 addView 动作开启视图绘制逻辑；
    
3. 创建 Activity 的 ViewRootImpl 对象；
    
4. 执行 ViewRootImpl 的 setView 函数开启 UI 界面绘制动作；

## 应用 UI 布局与绘制
应用主线程中在执行 Activity 的 Resume 流程的最后，会创建 [[ViewRootImpl]] 对象并调用其 setView 函数，从此并开启了应用界面 UI 布局与绘制的流程。

## RenderThread渲染
在 ViewRootImpl 中完成了对界面的 measure、layout 和 draw 等绘制流程后，用户依然还是看不到屏幕上显示的应用界面内容，因为整个 Android 系统的显示流程除了前面讲到的 UI 线程的绘制外，界面还需要经过 RenderThread 线程的渲染处理，渲染完成后，还需要通过 Binder 调用 “上帧” 交给 surfaceflinger 进程中进行合成后送显才能最终显示到屏幕上。
1. 从 DecorView 根节点出发，递归遍历 View 控件树，记录每个 View 节点的 drawOp 绘制操作命令，完成绘制操作命令树的构建；
    
2. JNI 调用同步 Java 层构建的绘制命令树到 Native 层的 RenderThread 渲染线程，并唤醒渲染线程利用 OpenGL 执行渲染任务；
# 一对 AIDL 双向通讯  
IApplicationThread 和 IActivityManager 是一对配套的 AIDL 接口

-   IActivityManager 负责 Activity -> ActivityManagerService 的通讯
-   IApplicationThread 负责 ActivityManagerService -> Activity 的通讯
-   双向通讯的绑定是在 Activity 拿到同 ActivityManagerService 通讯的 AIDL 时把自己的 IApplicationThread 也就是反向 AIDL 接口交给 ActivityManagerService ，这样2者形成 AIDL 双向通讯






