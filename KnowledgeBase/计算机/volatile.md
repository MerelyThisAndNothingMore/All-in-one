---
tags: 
alias:
---

关键字volatile可以说是[[Java 虚拟机]]提供的最轻量级的同步机制，但是它并不容易被正确、完整地 理解，以至于许多程序员都习惯去避免使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。

## 可见性

当一个变量被定义成volatile之后，它将具备两项特性:第一项是保证此变量对所有线程的可见 性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过[[主内存]]来完成。

volatile变量在各个线程的工作内存中是不存在一致性问题的(从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看 不到不一致的情况，因此可以认为不存在一致性问题)，但是[[Java]]里面的运算操作符并非原子操作， 这导致volatile变量的运算在并发下一样是不安全的。

> 只有一行代码的increase()[[方法]]在[[Class文件]]中是由4条[[字节码]]指令构成:当getstatic指令把 race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst\_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以 putstatic指令执行后就可能把较小的race值同步回主内存之中

## 顺序性

使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的 所谓“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)。

有volatile修饰的变量,赋值后多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个内存屏障 (Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置，只有一个处理器访问内存时，并不需要内存屏障;但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。

这句指令中的“ addl$0x0，(%esp )”(把ESP寄存器的值加0)显然是一个空操作，之所以用这个空操作而不是空操作专用指令nop，是因为IA32手册规定lock前缀不允许配合nop指令使用。这里的关键在于lock前缀，查询IA32手册可知，**它的作用是将本处理器的缓存写入了内存，该写入动作也会引起别的处理器或者别的内核无效化(Invalidate)其[[缓存]]**，这种操作相当于对缓存中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。所以通过这样一个空操作，可让前面volatile变量的修改对其他处理器立即可见。







![](https://gd-hbimg.huaban.com/037a6f26772aac082a3abc806e76f4d3655359c36640-4ZTaWF_fw1200webp)

![](https://gd-hbimg.huaban.com/a0bf8fdd9ba4fe096b88c5b90174b3f3dee64cbabac8-NX2dTV)
