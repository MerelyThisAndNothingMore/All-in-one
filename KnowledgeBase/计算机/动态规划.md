---
tags: 
aliases:
  - Dynamic Programming
  - DP
---

# 定义

动态规划（Dynamic Programming, DP）是一种用于解决具有重叠子问题和最优子结构性质的复杂问题的[[算法]]方法。通过将原问题分解为更小的子问题，逐个解决并存储子问题的解，动态规划能够高效地求解问题的最优解。

## 特点

1. **重叠子问题**：原问题可以分解为多个相互重叠的子问题。
2. **最优子结构**：问题的最优解包含其子问题的最优解。
3. **记忆化**：通过存储子问题的解避免重复计算，提高算法效率。
4. **自底向上**：通常采用自底向上的方式解决问题，从最简单的子问题逐步解决到原问题。
5. **状态转移方程**：通过状态转移方程定义子问题之间的关系。

## 相似概念辨析

### 动态规划 vs 递归

1. **计算方式**：
   - **动态规划**：通过存储子问题的解，避免重复计算。
   - **递归**：通过[[递归]]调用解决子问题，可能存在大量重复计算。

2. **[[时间复杂度]]**：
   - **动态规划**：时间复杂度通常较低，因为每个子问题只计算一次。
   - **递归**：时间复杂度通常较高，尤其是存在大量重复计算时。

3. **[[空间复杂度]]**：
   - **动态规划**：需要额外的空间来存储子问题的解。
   - **递归**：需要额外的空间来维护递归调用栈。

### 动态规划 vs [[贪心算法]]

1. **全局最优性**：
   - **动态规划**：保证全局最优解。
   - **贪心算法**：只能保证局部最优解，不能保证全局最优解。

2. **适用问题**：
   - **动态规划**：适用于具有重叠子问题和最优子结构的问题。
   - **贪心算法**：适用于贪心选择性质的问题。

3. **实现方式**：
   - **动态规划**：通过构建状态转移方程，逐步求解子问题。
   - **贪心算法**：通过逐步选择当前最优解，构建最终解。

# 原理

动态规划的基本思想是将原问题分解为更小的子问题，解决每个子问题并存储其结果，以便在需要时可以直接使用。动态规划通常包含以下步骤：

1. **定义子问题**：将原问题分解为更小的子问题。
2. **递推关系**：确定子问题之间的关系，构建状态转移方程。
3. **存储中间结果**：通过[[数组]]或表格存储子问题的解。
4. **构建最终解**：通过递推关系和存储的中间结果构建原问题的最优解。

# 示例：斐波那契数列

[[斐波那契数列]]是动态规划的经典示例，定义如下：

$$
F(n) = \begin{cases} 
0 & \text{if } n = 0 \\
1 & \text{if } n = 1 \\
F(n-1) + F(n-2) & \text{if } n > 1 
\end{cases}
$$

直接递归计算斐波那契数列的时间复杂度为 $O(2^n)$。使用动态规划可以将其时间复杂度降低到 $O(n)$。

# 使用

动态规划在各种优化问题中有广泛应用，以下是一些经典问题：

1. **背包问题**：求解在给定容量的背包中放入物品的最大价值。
2. **最长公共子序列**：求解两个序列的最长公共子序列。
3. **最短路径问题**：求解[[图]]中从一个顶点到另一个顶点的最短路径。
4. **矩阵链乘法**：求解矩阵链乘法的最优计算顺序。
5. **编辑距离**：求解两个字符串之间的最小编辑距离。

# Q & A

**Q1: 动态规划与分治法有何区别？**

A1: 动态规划和[[分治]]法都通过分解问题来求解，但动态规划通过存储子问题的解来避免重复计算，而分治法则直接递归求解子问题，可能存在大量重复计算。

**Q2: 动态规划如何处理高维度问题？**

A2: 动态规划可以通过增加状态变量来处理高维度问题，但需要注意的是，高维度问题的空间复杂度和时间复杂度可能会显著增加。

**Q3: 如何确定动态规划的状态和状态转移方程？**

A3: 确定状态和状态转移方程是动态规划的关键。通常，通过分析问题的最优子结构和重叠子问题，可以找到合适的状态定义，并构建相应的状态转移方程。

**Q4: 动态规划是否总能找到问题的最优解？**

A4: 动态规划适用于具有最优子结构和重叠子问题性质的问题。在这些问题中，动态规划能够找到问题的最优解。但并非所有问题都适用于动态规划，需要根据具体问题进行分析。

**Q5: 动态规划的时间复杂度和空间复杂度如何？**

A5: 动态规划的时间复杂度和空间复杂度取决于问题的状态数量和状态转移方程的计算复杂度。通常，时间复杂度为状态数量的多项式级别，而空间复杂度则取决于存储中间结果所需的空间。